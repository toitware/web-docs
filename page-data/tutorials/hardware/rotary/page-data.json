{
    "componentChunkName": "component---src-components-layout-mdx-layout-tsx",
    "path": "/tutorials/hardware/rotary",
    "result": {"data":{"site":{"siteMetadata":{"title":"Toit documentation"}},"mdx":{"body":"const _excluded = [\"components\"];\n\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\n\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\n\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nconst _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"rotary-encoder\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#rotary-encoder\",\n    \"aria-label\": \"rotary encoder permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Rotary encoder`), mdx(\"p\", null, `In this tutorial we are going to use the ESP32's pulse counter to read a rotary encoder.`), mdx(\"p\", null, `A rotary encoder is usually a wheel or a knob that turns freely without any limits or stops.\n(Picture)`), mdx(\"p\", null, `Typically a rotary encoder has two output signals:`), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, `CLK (sometimes called A)`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `DT (sometimes called B)`)), mdx(\"p\", null, `These two signals create square-wave pulses as you rotate the knob:`), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, `Clockwise rotation:  (CLK leads DT)`)), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `CLK:   ┌───┐   ┌───┐\n     ──┘   └───┘   └───┘\nDT:      ┌───┐   ┌───┐\n     ────┘   └───┘   └───┘\n`)), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, `Counter-clockwise rotation:  (DT leads CLK)`)), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `CLK:     ┌───┐   ┌───┐\n     ────┘   └───┘   └───┘\nDT:    ┌───┐   ┌───┐\n     ──┘   └───┘   └───┘\n`)), mdx(\"p\", null, `Put simply, if we look at the 'rising edge' (the first moment the CLK goes up), we can check to\nsee what the state of the DT pin is. If DT is low when CLK rises, the encoder is turning in one\ndirection. If DT is high when CLK rises, then its being turned the other way.`), mdx(\"p\", null, `On many platforms, we have to manually code states that track these and act on those using logic\nwith a timer. The ESP32 platform has a hardware\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/peripherals/pcnt.html\"\n  }, `pulse-counter module (PCNT)`), `\nonboard which Toit exposes using the `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://libs.toit.io/pulse-counter/library-summary\"\n  }, `'pulse-counter' library`), `.`), mdx(\"p\", null, `Using this peripheral we can simply tie our rotary encoder pins to this module to help us track 'intents', a\nsingle click of rotation. Our code can then watch that counter to determine what is happening\nwith those rotations.`), mdx(\"h2\", {\n    \"id\": \"prerequisites\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#prerequisites\",\n    \"aria-label\": \"prerequisites permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Prerequisites`), mdx(\"p\", null, `We assume that you have set up your development environment as described\nin `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../setup/ide\"\n  }, `the IDE tutorial`), `.`), mdx(\"p\", null, `We also assume that you have flashed your device with Jaguar and that\nyou are familiar with running Toit programs on it.\nIf not, have a look at the `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../setup/firstprogram\"\n  }, `Hello world`), ` tutorial.`), mdx(\"h2\", {\n    \"id\": \"setup\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#setup\",\n    \"aria-label\": \"setup permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Setup`), mdx(\"p\", null, `Connect your rotary encoder KY-04 (or similar) as follows:`), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, `CLK (or A) to pin 32.`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `DT (or B) to pin 33.`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `SW (or switch) to pin 25 (optional, if your encoder has a push-button).`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `3.3V to the + (or VCC) pin of the encoder.`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `GND to the GND pin of the encoder.`)), mdx(\"p\", null, `Take care if using your own unmounted encoders as soldering irons can easily harm the\ncomponents inside.`), mdx(\"img\", {\n    src: RotaryDiagram,\n    alt: \"KY-040 diagram\"\n  }), mdx(\"img\", {\n    src: RotarySchematics,\n    alt: \"KY-040 schematics\"\n  }), mdx(\"h2\", {\n    \"id\": \"code\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#code\",\n    \"aria-label\": \"code permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Code`), mdx(\"p\", null, `Create a new file `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `rotary.toit`), ` and put the following code into it:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toit\"\n  }, `import gpio\nimport pulse-counter show Unit Channel\n\nCLK-PIN ::= 32\nDT-PIN ::= 33\nSW-PIN ::= 25\n\nmain:\n  // Set up the pins and the counter.\n  clk := gpio.Pin CLK-PIN\n  dt := gpio.Pin DT-PIN\n  sw := gpio.Pin SW-PIN --input --pull-down\n\n  // Since we only need one channel, we can just configure the channel while\n  // creating the pulse counter. If multiple channels are changing a\n  // counter (unit), then we would need to create a list of channels and pass\n  // that to the pulse-counter.Unit constructor.\n  counter := Unit clk --control-pin=dt\n      --on-positive-edge=Channel.EDGE-INCREMENT\n      --on-negative-edge=Channel.EDGE-DECREMENT\n      --when-control-low=Channel.CONTROL-KEEP\n      --when-control-high=Channel.CONTROL-INVERSE\n\n  // Start the counter.\n  counter.start\n\n  last-count := counter.value\n\n  while true:\n    // Read the current count.\n    current-count := counter.value\n\n    // If the count has changed, print the new value.\n    if current-count != last-count:\n      direction := (current-count > last-count) ? \"clockwise\" : \"counter-clockwise\"\n      print \"Rotated $direction: $current-count\"\n\n    if sw.get == 0:\n      counter.clear\n      print \"Button pressed (counter cleared)\"\n\n    // Sleep for a short while to avoid busy-waiting.\n    sleep --ms=100\n    last-count = current-count\n`)), mdx(\"p\", null, `This code allocates a pulse counter unit with one channel. Using the\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `--on-positive-edge`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `--on-negative-edge`), ` options we tell the pulse counter\nto increment the counter when the CLK pin goes high, and decrement it when it\ngoes low. If the encoder is turned in one direction the control pin switches\npolarity between these two events, and the counter thus continuously counts\nup or down.`), mdx(\"p\", null, `For simplicity we use polling to detect when the switch is pressed. One could\nalso use a task and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `gpio.Pin.wait-for`), ` to detect the switch press asynchronously.`), mdx(\"p\", null, `There is currently no way to detect changes in the counter asynchronously. If\npins are free, then just connecting CLK to a second pin and using\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `wait-for`), ` to detect changes in the counter is a simple work-around.`), mdx(\"h2\", {\n    \"id\": \"exercises\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#exercises\",\n    \"aria-label\": \"exercises permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Exercises`), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, `Combine the rotary encoder and the\n`, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.toit.io/tutorials/hardware/ssd1306\"\n  }, `SSD 1306 display`), ` to show a\ncounter that increments and decrements as you turn the encoder.`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `Use asynchronous tasks to detect the switch press and the counter changes.`)));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#rotary-encoder","title":"Rotary encoder","items":[{"url":"#prerequisites","title":"Prerequisites"},{"url":"#setup","title":"Setup"},{"url":"#code","title":"Code"},{"url":"#exercises","title":"Exercises"}]}]}}},"pageContext":{"title":"Rotary encoder","id":"a30e0e92-69e7-5d9a-b608-753c6dd93b0b"}},
    "staticQueryHashes": ["2197327828"]}