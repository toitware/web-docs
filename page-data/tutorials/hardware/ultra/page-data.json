{
    "componentChunkName": "component---src-components-layout-mdx-layout-tsx",
    "path": "/tutorials/hardware/ultra",
    "result": {"data":{"site":{"siteMetadata":{"title":"Toit documentation"}},"mdx":{"body":"const _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nconst _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"hc-sr04---ultrasonic-distance-sensor\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#hc-sr04---ultrasonic-distance-sensor\",\n    \"aria-label\": \"hc sr04   ultrasonic distance sensor permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `HC-SR04 - ultrasonic distance sensor`), mdx(\"p\", null, `The HC-SR04 is a popular ultrasonic distance sensor. It is cheap and easy to\nuse. The sensor has on speaker and one microphone. The speaker sends out a\nultrasonic pulse and the microphone listens for the echo. The time between\nsending the pulse and receiving the echo can be used to calculate the distance.`), mdx(\"h2\", {\n    \"id\": \"prerequisites\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#prerequisites\",\n    \"aria-label\": \"prerequisites permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Prerequisites`), mdx(\"p\", null, `We assume that you have set up your development environment as described\nin `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../setup/ide\"\n  }, `the IDE tutorial`), `.`), mdx(\"p\", null, `We also assume that you have flashed your device with Jaguar and that\nyou are familiar with running Toit programs on it.\nIf not, have a look at the `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../setup/firstprogram\"\n  }, `Hello world`), ` tutorial.`), mdx(\"p\", null, `We recommend that you have finished the `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../led\"\n  }, `LED tutorial`), ` before\nstarting this tutorial.`), mdx(\"h2\", {\n    \"id\": \"setup\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#setup\",\n    \"aria-label\": \"setup permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Setup`), mdx(\"p\", null, `Connect the HC-SR04 as follows:`), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, `VCC to 5V/VIN.`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `GND to GND.`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `TRIG to pin 33.`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `ECHO to an LED and then to pin 32. The anode (long leg) of the LED should be\nconnected to the ECHO pin and the cathode (short leg) to pin 32.`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `Optionally, add a 10kΩ resistor (or higher) between pin 32 and GND.`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `Optionally, add a 100kΩ resistor (or higher) between pin 33 and GND.`)), mdx(\"p\", null, `The HC-SR04 is designed to run on 5V, and is known to be flaky at lower\nvoltages. ESP32 boards usually have a 5V output, often labeled as VIN,\nbut the ESP32 is not 5V tolerant on its inputs (depending on who you ask).\nThis means that you should not connect the ECHO pin directly to the ESP32.\nInstead, we connect the ECHO pin to an LED and then to the ESP32. LEDs have\na forward voltage drop of around 2V, so the voltage on the ECHO pin will\nbe around 3V, which is safe for the ESP32. See the\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../adc#led-voltage-drop\"\n  }, `ADC tutorial`), ` for a setup where we measure the\nLED voltage drop. The 10kΩ resistor is optional, but ensures that the\nLED is used in a linear regime where we can trust that the signal is\ncorrectly received by the ESP32 and where the voltage drop is\naround 2V. The 100kΩ resistor is just a pull-down resistor that ensures\nthat the TRIG pin isn't floating when not in use. When floating, the\nsensor could trigger, sometimes frequently, when our program isn't running.`), mdx(\"p\", null, `If you have an HC-SR04+ module, then you can connect the VCC to 3V3 instead\nand connect the ECHO pin directly to the ESP32. The \"+\" version of the\nHC-SR04 is designed to run on 3.3V. Note that the \"+\" is not printed\non the front of the module, but only on the back.`), mdx(\"img\", {\n    src: UltraDiagram,\n    alt: \"HC-SR04 wiring diagram\"\n  }), mdx(\"img\", {\n    src: UltraSchematics,\n    alt: \"HC-SR04 schematics\"\n  }), mdx(\"h2\", {\n    \"id\": \"measuring-by-hand\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#measuring-by-hand\",\n    \"aria-label\": \"measuring by hand permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Measuring by hand`), mdx(\"p\", null, `Conceptually, the HC-SR04 works as follows: after receiving a pulse on\nthe TRIG pin (of ~10us), it sends out an ultrasonic pulse. At that moment\nit sets the ECHO pin high and waits for an echo. The moment it receives\nthe echo, it sets the ECHO pin low again. The time between the ECHO pin going\nhigh and low thus corresponds to the time it took for the ultrasonic pulse\nto travel to the object and back. This time can be used to calculate the\ndistance to the object.`), mdx(\"p\", null, `Here is a simple program that measures the distance to an object and prints\nit to the console.`), mdx(\"p\", null, `Save it as `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `ultra.toit`), ` and watch it with Jaguar.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toit\"\n  }, `import gpio\n\nTRIGGER ::= 33\nECHO ::= 32\n\nmeasure-distance trigger echo:\n  trigger-start := Time.monotonic-us\n  trigger.set 1\n  while Time.monotonic-us < trigger-start + 10:\n    // Do nothing while waiting for the 10us.\n  trigger.set 0\n\n  while echo.get != 1: null\n  echo-start := Time.monotonic-us\n  while echo.get == 1: null\n  echo-end := Time.monotonic-us\n  diff := echo-end - echo-start\n  return diff / 58\n\nmain:\n  trigger := gpio.Pin TRIGGER --output\n  echo := gpio.Pin ECHO --input\n  while true:\n    print \"measured $(measure-distance trigger echo)cm\"\n    sleep --ms=500\n`)), mdx(\"p\", null, `The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `measure-distance`), ` function does all the work:`), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, `Set the trigger to 1 for at least 10μs.`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `Wait for the echo pin to go high.`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `Measure the duration of the echo-pin pulse.`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `Convert the duration in microseconds to centimeters.`)), mdx(\"h3\", {\n    \"id\": \"exercises\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#exercises\",\n    \"aria-label\": \"exercises permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Exercises`), mdx(\"p\", null, `As long as the connections were done correctly it is difficult\nto damage your hardware by changing your program. Just make sure\nthat the ECHO pin is always an input pin.`), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, `Given that the speed of sound is 343m/s, explain the constant\n58 to convert from measured microseconds to centimeters.`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `Repeat the measurement multiple times and average it, to get a\nmore accurate distance.`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `Find a material that absorbs ultrasonic waves and is thus\n\"invisible\" to the sensor.`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `What's the furthest distance the sensor is able to detect?`)), mdx(\"h2\", {\n    \"id\": \"measuring-using-the-hardware\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#measuring-using-the-hardware\",\n    \"aria-label\": \"measuring using the hardware permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Measuring using the hardware`), mdx(\"p\", null, `Measuring the length of the echo pulse in Toit works but it is\na bit brittle. Toit is not designed to be a real-time language,\nand with all the capabilities of the ESP32 chip, it's rarely\nnecessary to do real-time work. Case in point, there is a\ngreat ESP32 peripheral \"RMT\" (Remote Control Transceiver) that\ncan do the time measurement in hardware for us.`), mdx(\"p\", null, `The published `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://pkg.toit.io/package/github.com%2Flask%2Ftoit-hc-sr04@v2\"\n  }, `hc_sr04`), ` package uses the hardware and\nis thus more precise and uses less CPU.`), mdx(\"p\", null, `Install the package as usual with `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `jag pkg install`), `:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-shell\"\n  }, `jag pkg install github.com/lask/toit-hc-sr04@v2\n`)), mdx(\"p\", null, `See the `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../setup/packages\"\n  }, `package tutorial`), ` for more information\nabout packages.`), mdx(\"p\", null, `We can now simplify the code:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toit\"\n  }, `import gpio\nimport hc-sr04\n\nTRIGGER ::= 33\nECHO ::= 32\n\nmain:\n  trigger := gpio.Pin TRIGGER\n  echo := gpio.Pin ECHO\n  sensor := hc-sr04.Driver --echo=echo --trigger=trigger\n\n  while true:\n    distance := sensor.read-distance\n    print \"measured $distance mm\"\n    sleep --ms=500\n`)), mdx(\"p\", null, `Measuring the echo pulse is now done in hardware and the\nresulting values should be much more precise. The measurements\nare also unaffected by other containers that could use the\nCPU.`));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#hc-sr04---ultrasonic-distance-sensor","title":"HC-SR04 - ultrasonic distance sensor","items":[{"url":"#prerequisites","title":"Prerequisites"},{"url":"#setup","title":"Setup"},{"url":"#measuring-by-hand","title":"Measuring by hand","items":[{"url":"#exercises","title":"Exercises"}]},{"url":"#measuring-using-the-hardware","title":"Measuring using the hardware"}]}]}}},"pageContext":{"title":"HC-SR04 - ultrasonic distance sensor","id":"bf5ae6d8-672d-5936-b527-12d51f5073cf"}},
    "staticQueryHashes": ["2197327828"]}