{
    "componentChunkName": "component---src-components-layout-mdx-layout-tsx",
    "path": "/tutorials/misc/ota",
    "result": {"data":{"site":{"siteMetadata":{"title":"Toit documentation"}},"mdx":{"body":"const _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nconst _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return mdx(\"div\", props);\n};\n\nconst Note = makeShortcode(\"Note\");\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"over-the-air-ota-updates\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#over-the-air-ota-updates\",\n    \"aria-label\": \"over the air ota updates permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Over the air (OTA) Updates`), mdx(\"p\", null, `In this tutorial we will learn how to update the firmware of the ESP32\nover the air (OTA). This mechanism is used by `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `jag firmware update`), ` or\nby `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/toitware/artemis-releases\"\n  }, `Artemis`), ` whenever\na new firmware is sent to the device.`), mdx(\"h2\", {\n    \"id\": \"prerequisites\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#prerequisites\",\n    \"aria-label\": \"prerequisites permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Prerequisites`), mdx(\"p\", null, `We assume that you have set up your development environment as described\nin `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../setup/ide\"\n  }, `the IDE tutorial`), `.`), mdx(\"p\", null, `We also assume that you have flashed your device with Jaguar and that\nyou are familiar with running Toit programs on it.\nIf not, have a look at the `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../setup/firstprogram\"\n  }, `Hello world`), ` tutorial.`), mdx(\"p\", null, `The OTA program will use HTTP to download the new firmware. While not\nnecessary, you can have a look at the `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../network/http\"\n  }, `HTTP tutorial`), `\nfirst.`), mdx(\"p\", null, `A new firmware consists of updating a Toit firmware envelope with\nthe desired containers and to build a binary image out of it.\nWe will provide the necessary steps to create a new firmware, but\nyou might need to update your setup to have the required tools\n(`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `toit.compile`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `firmware`), `) accessible. See the\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../containers/toit-sdk\"\n  }, `containers tutorial`), ` for how to\nset up your environment, and for more information on how containers\nand envelopes work.`), mdx(\"h2\", {\n    \"id\": \"packages\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#packages\",\n    \"aria-label\": \"packages permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Packages`), mdx(\"p\", null, `We are going to download the new firmware through HTTP. As such, we will\nuse the\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://pkg.toit.io/package/github.com%2Ftoitlang%2Fpkg-http@v2\"\n  }, `http`), `\npackage. To install it, run the following command:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-shell\"\n  }, `jag pkg install github.com/toitlang/pkg-http@v2\n`)), mdx(\"p\", null, `See the `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../setup/packages\"\n  }, `packages`), `\ntutorial for more information on Toit's package management system.`), mdx(Note, {\n    mdxType: \"Note\"\n  }, mdx(\"p\", null, `You can probably just write `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `jag pkg install http`), `, but the full ID together\nwith the version is more explicit, and will make sure you get the right package.`)), mdx(\"h2\", {\n    \"id\": \"introduction\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#introduction\",\n    \"aria-label\": \"introduction permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Introduction`), mdx(\"p\", null, `The ESP32 has two partitions for storing firmware. This allows us to\nupdate the firmware without the risk of bricking the device. The\nfirmware is always running from one of the partitions, while the other\none is used for updating the firmware. When the update is complete, the\ndevice will reboot and run the new firmware. To avoid getting stuck with\na bad firmware, the new firmware then needs to \"validate\" the update.\nOtherwise, the device runs the old firmware again once it reboots.`), mdx(\"p\", null, `In this tutorial we will thus have two programs: one that downloads the\nnew firmware and writes it to the other partition, and one that is\nrun with the new firmware and validates the update.`), mdx(\"h2\", {\n    \"id\": \"the-validator\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#the-validator\",\n    \"aria-label\": \"the validator permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `The validator`), mdx(\"p\", null, `The validator is a simple program that prints a message and then\nvalidates the update. Without that step the device would boot into\nthe old firmware after a reboot. (Feel free to leave the validation\nout if you want to test the recovery mechanism.)`), mdx(\"p\", null, `Typically, a validating program would check some important properties,\nlike access to a server, before validating the update. If the check\nfails, the program would eventually just reboot the device, which would\nthen run the old firmware again.`), mdx(\"p\", null, `Create a file `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `validate.toit`), ` with the following content:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toit\"\n  }, `import system.firmware\n\nmain:\n  print \"hello after update\"\n\n  if firmware.is-validation-pending:\n    if firmware.validate:\n      print \"firmware update validated\"\n    else:\n      print \"firmware update failed to validate\"\n`)), mdx(\"p\", null, `This program imports the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `system.firmware`), ` library, which provides\nthe `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `is-validation-pending`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `validate`), ` functions. The first function\nreturns `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `true`), ` if the device booted into a new firmware, but has not\nyet validated the update. The second function validates the update and\nreturns `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `true`), ` if the validation was successful.`), mdx(\"h2\", {\n    \"id\": \"preparing-the-new-firmware\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#preparing-the-new-firmware\",\n    \"aria-label\": \"preparing the new firmware permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Preparing the new firmware`), mdx(\"p\", null, `A new firmware needs to be extracted from Toit's firmware envelopes. Each\nSDK version comes with a set of envelopes the user can choose from. See\nthe `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/toitlang/toit/releases\"\n  }, `release assets`), ` for the\nlatest SDK release and its envelopes.`), mdx(\"p\", null, `Download the envelope you want to use. For this tutorial we will use\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `firmware-esp32.gz`), `. Gunzip it and extract the file:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-shell\"\n  }, `gunzip firmware-esp32.gz\n`)), mdx(\"p\", null, `You should now have a file called `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `firmware-esp32`), `.`), mdx(\"p\", null, `Compile the validate program to a snapshot and add it to the envelope:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-shell\"\n  }, `toit.compile -w validate.snapshot validate.toit\nfirmware -e firmware-esp32 container install validate validate.snapshot\n`)), mdx(\"p\", null, `Optionally, add other containers to the envelope.`), mdx(\"p\", null, `Run the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `firmware`), ` tool again to extract a binary image from the envelope:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-shell\"\n  }, `firmware -e firmware-esp32 extract --format=binary -o ota.bin\n`)), mdx(\"h3\", {\n    \"id\": \"makefile\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#makefile\",\n    \"aria-label\": \"makefile permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Makefile`), mdx(\"p\", null, `For reference, here is a Makefile that creates an `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `ota.bin`), ` file. It uses a\ndifferent name for the envelope file (`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `firmware.envelope`), `), but otherwise\nfollows the same steps.`), mdx(\"p\", null, `The paths are set up for a Linux system with the Toit SDK installed in\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `/opt/toit-sdk`), `. You might need to adjust the paths to match your setup.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-makefile\"\n  }, `TOIT_SDK := /opt/toit-sdk\nTOIT_COMPILE := $(TOIT_SDK)/bin/toit.compile\nTOIT_FIRMWARE := $(TOIT_SDK)/tools/firmware\nVERSION := $(shell $(TOIT_SDK)/bin/toit.lsp version)\nENVELOPE_URL := https://github.com/toitlang/toit/releases/download/$(VERSION)/firmware-esp32.gz\n\n.PHONY: all\nall: ota.bin\n\n# Always repuild the firmware envelope since we modify it.\n.PHONY: firmware.envelope\nfirmware.envelope: firmware.envelope.gz\n    gunzip -c firmware.envelope.gz > firmware.envelope\n\nfirmware.envelope.gz:\n    curl -L -o $@ $(ENVELOPE_URL)\n\n%.snapshot: %.toit\n    $(TOIT_COMPILE) -w $@ $<\n\nota.bin: validate.snapshot firmware.envelope\n    $(TOIT_FIRMWARE) -e firmware.envelope container install validate validate.snapshot\n    $(TOIT_FIRMWARE) -e firmware.envelope extract --format=binary -o ota.bin\n\n.PHONY: serve\nserve: ota.bin\n    python3 -m http.server 8000\n\n.PHONY: version\nversion:\n    @echo $(VERSION)\n`)), mdx(\"h2\", {\n    \"id\": \"serving-the-new-firmware\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#serving-the-new-firmware\",\n    \"aria-label\": \"serving the new firmware permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Serving the new firmware`), mdx(\"p\", null, `For this tutorial the new firmware needs to be served over HTTP. You can use\nany HTTP server you want, including the one presented in\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../network/http-file-server\"\n  }, `the HTTP file server tutorial`), `, but for\nsimplicity we will use Python's built-in HTTP server.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-shell\"\n  }, `python3 -m http.server\n`)), mdx(\"p\", null, `This will serve the current directory on port 8000. Make sure the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `ota.bin`), `\nfile is in the current directory.`), mdx(\"p\", null, `Now find the IP address of your desktop computer. You can use one\nof the following commands to find your LAN address:`), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, `Linux: `, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, `ip -j route get 1`)), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `Macos: `, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, `route -n get default`)), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `Windows: `, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, `ipconfig`))), mdx(\"h2\", {\n    \"id\": \"installing-the-firmware\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#installing-the-firmware\",\n    \"aria-label\": \"installing the firmware permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Installing the firmware`), mdx(\"p\", null, `We will now write a program that downloads the new firmware and writes\nit to the other partition. Create a file `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `ota.toit`), ` with the following\ncontent. Don't forget to replace `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `<YOUR_IP>`), ` with the IP address of your\ndesktop computer, as found in the previous step.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toit\"\n  }, `import http\nimport io\nimport net\nimport system.firmware\n\nUPDATE-URL := \"http://<YOUR_IP>:8000/ota.bin\"\n\ninstall-firmware reader/io.Reader -> none:\n  firmware-size := reader.content-size\n  print \"installing firmware with $firmware-size bytes\"\n  written-size := 0\n  writer := firmware.FirmwareWriter 0 firmware-size\n  try:\n    last := null\n    while data := reader.read:\n      written-size += data.size\n      writer.write data\n      percent := (written-size * 100) / firmware-size\n      if percent != last:\n        print \"installing firmware with $firmware-size bytes ($percent%)\"\n        last = percent\n    writer.commit\n    print \"installed firmware; ready to update on chip reset\"\n  finally:\n    writer.close\n\nmain:\n  network := net.open\n  client := http.Client network\n  try:\n    response := client.get --uri=UPDATE-URL\n    install-firmware response.body\n  finally:\n    client.close\n    network.close\n  firmware.upgrade\n`)), mdx(\"p\", null, `Note that the program expects the server to return a `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Content-Length`), `\nheader with the size of the firmware. Given this header, the\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `body`), ` field of the response will have the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `content-size`), ` field set, giving\nus access to the size of the firmware. The program could also obtain the\nfirmware size in other ways.`), mdx(\"p\", null, `Flashing the firmware consists of three steps:`), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, `Create a `, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, `FirmwareWriter`), ` with the size of the firmware.`), mdx(\"li\", {\n    parentName: \"ol\"\n  }, `Write the firmware to the writer.`), mdx(\"li\", {\n    parentName: \"ol\"\n  }, `Commit the writer.`)), mdx(\"p\", null, `Finally, when the firmware is flashed, we call `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `firmware.upgrade`), ` to\nreboot the device and run the new firmware.`), mdx(\"h3\", {\n    \"id\": \"running-the-program\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#running-the-program\",\n    \"aria-label\": \"running the program permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Running the program`), mdx(\"p\", null, `Typically, this program would be executed without Jaguar, as part\nof a container that was installed together with the firmware.`), mdx(\"p\", null, `However, as long as Jaguar is not writing to the flash at the same time,\n(un)installing containers or a new firmware, it is safe to run the\nprogram with Jaguar. After a reboot the new firmware will then\nbe running without the Jaguar service. You would need to reflash\nthe device through Jaguar to get the Jaguar service back.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-shell\"\n  }, `jag run ota.toit\n`)), mdx(\"h2\", {\n    \"id\": \"wifi\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#wifi\",\n    \"aria-label\": \"wifi permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `WiFi`), mdx(\"p\", null, `Depending on how you have configured the network on your device, you might\nneed to bake the WiFi credentials into the OTA image. This can be done\nby adding a config file with the credentials to the extraction step.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-makefile\"\n  }, `WIFI_CREDENTIALS := {\"wifi.ssid\":\"<my-ssid>\",\"wifi.password\":\"<my-password>\"}\n\nota.bin: validate.snapshot firmware.envelope\n    $(TOIT_FIRMWARE) -e firmware.envelope container install validate validate.snapshot\n    $(TOIT_FIRMWARE) -e firmware.envelope property set wifi '$(WIFI_CREDENTIALS)'\n    $(TOIT_FIRMWARE) -e firmware.envelope extract --format=binary -o ota.bin\n`)), mdx(\"p\", null, `We also recommend to only validate a new image once a network connection has been\nestablished. Otherwise, the device might be able to boot, but not connect to the\nnetwork, and thus become unreachable.`), mdx(\"h2\", {\n    \"id\": \"conclusion\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#conclusion\",\n    \"aria-label\": \"conclusion permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Conclusion`), mdx(\"p\", null, `We have seen how to update the firmware of the ESP32 over the air.`), mdx(\"p\", null, `The program we wrote is very simple, but it can be extended to\ncheck for updates periodically, and to fetch the new firmware from\na public server (like a GitHub release page).`));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#over-the-air-ota-updates","title":"Over the air (OTA) Updates","items":[{"url":"#prerequisites","title":"Prerequisites"},{"url":"#packages","title":"Packages"},{"url":"#introduction","title":"Introduction"},{"url":"#the-validator","title":"The validator"},{"url":"#preparing-the-new-firmware","title":"Preparing the new firmware","items":[{"url":"#makefile","title":"Makefile"}]},{"url":"#serving-the-new-firmware","title":"Serving the new firmware"},{"url":"#installing-the-firmware","title":"Installing the firmware","items":[{"url":"#running-the-program","title":"Running the program"}]},{"url":"#wifi","title":"WiFi"},{"url":"#conclusion","title":"Conclusion"}]}]}}},"pageContext":{"title":"Over the air (OTA) Updates","id":"63feb850-c3bb-5b08-8bec-59fe568bb1d3"}},
    "staticQueryHashes": ["2197327828"]}