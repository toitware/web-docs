{
    "componentChunkName": "component---src-components-layout-mdx-layout-tsx",
    "path": "/tutorials/containers/services",
    "result": {"data":{"site":{"siteMetadata":{"title":"Toit documentation"}},"mdx":{"body":"const _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nconst _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"services\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#services\",\n    \"aria-label\": \"services permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Services`), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../../language/sdk/services\"\n  }, `Services`), ` are Toit's way of communicating\nbetween different containers. They build on top of low-level\nremote-procedure-calls (RPCs) and provide a higher-level abstraction for\ninter-container communication.`), mdx(\"h2\", {\n    \"id\": \"prerequisites\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#prerequisites\",\n    \"aria-label\": \"prerequisites permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Prerequisites`), mdx(\"p\", null, `We assume that you have set up your development environment as described\nin `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../setup/ide\"\n  }, `the IDE tutorial`), `.`), mdx(\"p\", null, `We also assume that you have flashed your device with Jaguar and that\nyou are familiar with running Toit programs on it.\nIf not, have a look at the `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../setup/firstprogram\"\n  }, `Hello world`), ` tutorial.`), mdx(\"p\", null, `Note that you can do this tutorial without a device. In that case,\nyou need to use the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `-d host`), ` option whenever you invoke\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `jag run`), `. The program will then run on your computer instead of on\na device. In this case will need to\n`, `[spawn]`, `(`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://libs.toit.io/core/process/library-summary#spawn(2%2C0%2C0%2Cpriority)\"\n  }, `https://libs.toit.io/core/process/library-summary#spawn(2%2C0%2C0%2Cpriority)`), `\nthe individual containers from your main program, instead of\nrunning them individually.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toit\"\n  }, `code-for-container1:\n  print \"running in container1\"\n\ncode-for-container2:\n  print \"running in container2\"\n\nmain:\n  // Spawn a new process for each container.\n  spawn:: code-for-container1\n  spawn:: code-for-container2\n`)), mdx(\"h2\", {\n    \"id\": \"api\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#api\",\n    \"aria-label\": \"api permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `API`), mdx(\"p\", null, `Services make it possible to provide APIs across container boundaries. Before\nusing multiple containers it is a good idea to implement the functionality\nin a single container first. Once you are happy with the API and have tested\nit, you can split the functionality into multiple containers.`), mdx(\"p\", null, `In this tutorial we will implement a simple notification service. Each\nclient can publish a message to the service, and the service will then\nforward the message to all other clients.`), mdx(\"p\", null, `As discussed above, it's a good idea to implement the functionality in a\nsingle container first.`), mdx(\"h3\", {\n    \"id\": \"code\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#code\",\n    \"aria-label\": \"code permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Code`), mdx(\"p\", null, `Create a new file `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `notification.toit`), ` and watch it with Jaguar.`), mdx(\"p\", null, `We will need a monitor channel later, so let's start with that.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toit\"\n  }, `import monitor\n`)), mdx(\"h4\", {\n    \"id\": \"api-1\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#api-1\",\n    \"aria-label\": \"api 1 permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `API`), mdx(\"p\", null, `Next, we specify the API we want to have using interfaces.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toit\"\n  }, `/**\nA notification service that connects multiple clients to each other.\n*/\ninterface NotificationService:\n  connect -> Connection\n\n/**\nA connection to a notification service.\n\nAll messages sent through the connection are broadcast to all other\n  connections.\n*/\ninterface Connection:\n  /** Closes the connection. */\n  close -> none\n  /** Sends a message to all other connected clients. */\n  send message/string -> none\n  /**\n  Receives a message from another client.\n  This method blocks until a message is received.\n  */\n  receive -> string\n`)), mdx(\"h4\", {\n    \"id\": \"implementation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#implementation\",\n    \"aria-label\": \"implementation permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Implementation`), mdx(\"p\", null, `We might need to adjust the API later, but this is a good starting point.\nLet's implement the service in a single-container context:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toit\"\n  }, `class NotificationService_ implements NotificationService:\n  clients_ := {:}\n  client-id_ := 0\n\n  connect -> Connection:\n    id := client-id_++\n    result := Connection_ id this\n    clients_[id] = result\n    return result\n\n  send-all_ message/string --sender/int -> none:\n    clients_.do: | client-id connection/Connection_ |\n      if client-id != sender:\n        connection.dispatch_ message\n\nclass Connection_ implements Connection:\n  id/int\n  service_/NotificationService_\n  channel/monitor.Channel ::= monitor.Channel 10\n\n  constructor .id .service_:\n\n  close -> none:\n    service_.clients_.remove id\n\n  send message/string -> none:\n    service_.send-all_ message --sender=id\n\n  receive -> string:\n    return channel.receive\n\n  dispatch_ message/string -> none:\n    channel.send message\n`)), mdx(\"p\", null, `This is a very simple implementation, but allows us to test the API\nand play around with it. The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `NotificationService_`), ` class keeps track\nof all clients and forwards messages to them. The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Connection_`), ` class\nis a thin wrapper around a\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../../language/tasks#channel\"\n  }, `monitor channel`), `. It is used to send and\nreceive messages.`), mdx(\"h4\", {\n    \"id\": \"test-program\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#test-program\",\n    \"aria-label\": \"test program permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Test program`), mdx(\"p\", null, `Let's implement some tasks that use this service:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toit\"\n  }, `run service/NotificationService --name/string:\n  connection/Connection? := service.connect\n  send-task/Task? := null\n  try:\n    send-task = task::\n      counter := 0\n      while true:\n        connection.send \"hello from $name ($(counter++))\"\n        sleep (Duration --s=(1 + (random 3)))\n\n    while true:\n      message := connection.receive\n      if message == \"quit\":\n        break\n      print \"$name received: $message\"\n\n  finally:\n    // Make sure we execute all of these finally statements\n    // even if one of them yields.\n    critical-do:\n      if send-task != null:\n        send-task.cancel\n      connection.close\n\nmain:\n  service := NotificationService_\n  runner1 := task:: run service --name=\"runner1\"\n  runner2 := task:: run service --name=\"runner2\"\n  runner3 := task:: run service --name=\"runner3\"\n\n  sleep (Duration --s=10)\n  main-connection := service.connect\n  main-connection.send \"quit\"\n  main-connection.close\n`)), mdx(\"p\", null, `Here we create 3 tasks that connect to the service. Each sends\na message at a random interval (1 to 3 seconds), and prints\nany messages it receives. The main tasks shuts everything\ndown after 10 seconds by sending a `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `quit`), ` message to the service\n(and thus to all clients).`), mdx(\"h2\", {\n    \"id\": \"services-1\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#services-1\",\n    \"aria-label\": \"services 1 permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Services`), mdx(\"p\", null, `Now that we have a working implementation, we can use services\nto make the API work across container boundaries.`), mdx(\"h3\", {\n    \"id\": \"service-interface\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#service-interface\",\n    \"aria-label\": \"service interface permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Service interface`), mdx(\"p\", null, `As before we start by specifying the interfaces.`), mdx(\"p\", null, `Create a `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `service.toit`), ` file and insert the following code.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toit\"\n  }, `import system.services show ServiceSelector\n\n/**\nA notification service that connects multiple clients to each other.\n*/\ninterface NotificationService:\n  static SELECTOR ::= ServiceSelector\n      --uuid=\"c6f4862f-c17f-4624-865b-fa19467865c5\"\n      --major=0\n      --minor=1\n\n  /**\n  Connects this client to the notification service.\n\n  Returns a handle (int) to the Connection.\n  */\n  connect -> int\n  static CONNECT-INDEX ::= 0\n\n  connection-send handle/int message/string -> none\n  static CONNECTION-SEND-INDEX ::= 1\n`)), mdx(\"p\", null, `This is very similar to the interface we used in the single-container\nimplementation. The main difference is that we have added a\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `ServiceSelector`), ` to the interface. This is used to identify the\nservice. The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `SELECTOR`), ` is used by the client to find the service,\nand the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `CONNECT-INDEX`), ` is used to find the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `connect`), ` method.`), mdx(\"p\", null, `We also removed the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Connection`), ` interface. This is because we\nwill not be able to pass objects across container boundaries.\nInstead we will use handles (integers) to identify connections.`), mdx(\"p\", null, `The service now also has the methods of the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Connection`), ` interface.\nThat is, it has the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `connection-send`), ` method. The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `receive`), ` method\nis not on the service, as we will use resource notifications for that.`), mdx(\"h3\", {\n    \"id\": \"provider\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#provider\",\n    \"aria-label\": \"provider permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Provider`), mdx(\"p\", null, `Next, we need to implement the service. Create a `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `provider.toit`), ` file\nand insert the following code.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toit\"\n  }, `import system.services show ServiceProvider ServiceResource ServiceHandler\nimport .service\n\nclass NotificationServiceProvider extends ServiceProvider\n    implements ServiceHandler:\n  connections_ ::= {:}\n\n  constructor:\n    super \"tutorial/notification\" --major=1 --minor=0\n    provides NotificationService.SELECTOR --handler=this\n\n  handle index/int arguments/any --gid/int --client/int -> any:\n    if index == NotificationService.CONNECT-INDEX:\n      connection := Connection this client\n      connections_[connection.id] = connection\n      return connection\n    if index == NotificationService.CONNECTION-SEND-INDEX:\n      sender := (this.resource client arguments[0]) as Connection\n      message := arguments[1]\n      connections_.do: | id connection/Connection |\n        if id != sender.id:\n          connection.dispatch_ message\n      return null\n    unreachable\n\n  remove-connection_ connection/Connection:\n    connections_.remove connection.id\n\nclass Connection extends ServiceResource:\n  static id-counter/int := 0\n\n  provider/NotificationServiceProvider\n  id/int\n\n  constructor .provider client/int:\n    id = id-counter++\n    super provider client --notifiable\n\n  dispatch_ message/string -> none:\n    notify_ message\n\n  on-closed -> none:\n    provider.remove-connection_ this\n`)), mdx(\"p\", null, `There is a lot of boilerplate code here. The provider must initialize\nits super class with a name and its version number (both usually\nonly used for debugging). It must also specify which selectors it\nprovides. In our case the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `NotificationServiceProvider`), ` is also the\nhandler of the service, which is why it implements the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `ServiceHandler`), `\ninterface and passes itself as handler for the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `provides`), ` call.`), mdx(\"p\", null, `The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `handle`), ` method is the main method of the provider. It is called\nwhen a client calls a method on the service. The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `index`), ` argument is\nused to identify the method, and the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `arguments`), ` argument is the\nobject that the client passed to the method. (See the\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../../language/sdk/services#serialization\"\n  }, `serialization section`), `\nfor information on what type the object can be of.)`), mdx(\"p\", null, `The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Connection`), ` is implemented as a resource. Resources have the advantage\nthat the framework automatically closes them if the client disappears. They\nalso have a built-in notification mechanism that allows us to send messages\nto the client without the client having to poll for them. This is,\nwhy the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `super`), ` call in the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Connection`), ` constructor has the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `--notifiable`), `\nflag.`), mdx(\"p\", null, `Since we often want to install the provider as a separate container, let's\nadd a `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `main`), ` function to that file:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toit\"\n  }, `main:\n  provider := NotificationServiceProvider\n  provider.install\n`)), mdx(\"h3\", {\n    \"id\": \"client\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#client\",\n    \"aria-label\": \"client permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Client`), mdx(\"p\", null, `Finally, we need to implement the client. Create a `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `client.toit`), ` file\nand insert the following code.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toit\"\n  }, `import monitor\nimport system.services show ServiceClient ServiceResourceProxy\nimport .service\n\nclass NotificationServiceClient extends ServiceClient:\n  static SELECTOR ::= NotificationService.SELECTOR\n\n  constructor selector=SELECTOR:\n    assert: selector.matches SELECTOR\n    super selector\n\n  connect -> Connection:\n    handle := invoke_ NotificationService.CONNECT-INDEX null\n    proxy := Connection this handle\n    return proxy\n\n  send_ handle/int message/string -> none:\n    invoke_ NotificationService.CONNECTION-SEND-INDEX [handle, message]\n\nclass Connection extends ServiceResourceProxy:\n  channel_ := monitor.Channel 10\n\n  constructor client/ServiceClient handle/int:\n    super client handle\n\n  send message/string -> none:\n    client := (client_ as NotificationServiceClient)\n    client.send_ handle_ message\n\n  receive -> string:\n    return channel_.receive\n\n  on-notified_ notification/any -> none:\n    channel_.send notification\n`)), mdx(\"p\", null, `The client code is typically the most human readable code as it is\nimported by users of the service (which are frequently unfamiliar\nwith the service implementation).`), mdx(\"p\", null, `Users of the service must instantiate a `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `NotificationServiceClient`), `.\nThey can then connect to it using the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `connect`), ` method. This returns\na `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Connection`), ` object that can be used to send and receive messages\nto and from the service.`), mdx(\"p\", null, `The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Connection`), ` object is implemented as a proxy. This means that\nit is a local object that forwards all method calls to the service.\nIt has a handle integer that identifies it to the service.`), mdx(\"p\", null, `Since the provider marked the resource as `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `--notifiable`), `, the proxy\ncan receive notifications from the provider. These are handled\nby the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `on-notified_`), ` method, which overrides the default\nimplementation in `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `ServiceResourceProxy`), `. The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `on-notified_`), ` method\nsimply forwards the notification to a channel, which is used by\nthe `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `receive`), ` method.`), mdx(\"h3\", {\n    \"id\": \"a-user\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#a-user\",\n    \"aria-label\": \"a user permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `A user`), mdx(\"p\", null, `Now that we have implemented the service, we can use it. Create\na `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `user.toit`), ` file and insert the following code.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toit\"\n  }, `import .client\n\nmain:\n  name := \"client - $Time.now\"\n  print \"My name is $name\"\n  main --name=name\n\nmain --name:\n  client := NotificationServiceClient\n  client.open\n  connection := client.connect\n  send-task/Task? := null\n  try:\n    send-task = task::\n      counter := 0\n      while true:\n        connection.send \"hello from $name ($(counter++))\"\n        sleep (Duration --s=(1 + (random 3)))\n\n    while true:\n      message := connection.receive\n      if message == \"quit\":\n        break\n      print \"$name received: $message\"\n\n  finally:\n    // Make sure we execute all of these finally statements\n    // even if one of them yields.\n    critical-do:\n      if send-task != null:\n        send-task.cancel\n      connection.close\n      client.close\n`)), mdx(\"p\", null, `This code is very similar to the code we used in the single-container\nimplementation. Instead of running in a task, this program now\nruns in a `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `main`), ` function. This is because we will run it in a\nseparate container. We added a second `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `main`), ` function with a\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `--name`), ` argument. We will use this for the case where we\nspawn multiple clients from the same program (see below). It is\nnot essential to services.`), mdx(\"h3\", {\n    \"id\": \"running-the-service\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#running-the-service\",\n    \"aria-label\": \"running the service permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Running the service`), mdx(\"p\", null, `If you have an actual device, you can install the service on the\ndevice with, for example Jaguar. Otherwise you can also run them\nlocally on your desktop machine. We will show both options.`), mdx(\"h4\", {\n    \"id\": \"jaguar\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#jaguar\",\n    \"aria-label\": \"jaguar permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Jaguar`), mdx(\"p\", null, `Jaguar does not support running multiple containers with the same sources.\nTo work around this, we create a `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `user2.toit`), ` file that just imports\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `user.toit`), ` and calls its `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `main`), `.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toit\"\n  }, `import .user as user\n\nmain:\n  user.main\n`)), mdx(\"p\", null, `We recommend you have a look at the\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../containers\"\n  }, `container tutorial`), ` for more information on how to\ninstall containers on a device. For our purpose the following\ncommand should work:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-shell\"\n  }, `jaguar container install provider provider.toit\njaguar container install user1 user.toit\njaguar container install user2 user2.toit\n`)), mdx(\"p\", null, `This will install the provider and two clients on the device. As\nsoon as the clients are installed they start sending messages to\neach other (through the provider).`), mdx(\"h4\", {\n    \"id\": \"local\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#local\",\n    \"aria-label\": \"local permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Local`), mdx(\"p\", null, `If you do not have a device, you can run the service locally. You\nwill have to spawn the individual containers from your main program.`), mdx(\"p\", null, `Write the following `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `spawn.toit`), ` file:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toit\"\n  }, `import .user as user\nimport .provider\nimport .client\n\nmain:\n  spawn::\n    provider := NotificationServiceProvider\n    provider.install\n    sleep (Duration --s=15)\n    provider.uninstall\n\n  spawn:: user.main --name=\"process1\"\n  spawn:: user.main --name=\"process2\"\n  spawn:: user.main --name=\"process3\"\n\n  sleep (Duration --s=10)\n  client := NotificationServiceClient\n  client.open\n  connection := client.connect\n  connection.send \"quit\"\n  connection.close\n  client.close\n`)), mdx(\"p\", null, `This program spawns the provider and three clients. It then waits\nfor 10 seconds and sends a \"quit\" message to the clients. The\nclients should then stop sending messages.`), mdx(\"p\", null, `You can run the program with:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-shell\"\n  }, `jaguar run -d host spawn.toit\n`)), mdx(\"h2\", {\n    \"id\": \"conclusion\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#conclusion\",\n    \"aria-label\": \"conclusion permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Conclusion`), mdx(\"p\", null, `In this tutorial, we have seen how to implement a service that\ncan be used by multiple clients. We have also seen how to run\nthe service on a device and how to run it locally.`), mdx(\"p\", null, `It should be straight-forward to extend this tutorial to other\nuse-cases that require coordination between different containers. For\nexample, you could implement a service that uses\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../mqtt\"\n  }, `MQTT`), `, `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../network/supabase\"\n  }, `Supabase`), `, or\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../network/telegram\"\n  }, `Telegram`), ` to send or receive data for\nmultiple containers without needing to open multiple connections.`));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#services","title":"Services","items":[{"url":"#prerequisites","title":"Prerequisites"},{"url":"#api","title":"API","items":[{"url":"#code","title":"Code","items":[{"url":"#api-1","title":"API"},{"url":"#implementation","title":"Implementation"},{"url":"#test-program","title":"Test program"}]}]},{"url":"#services-1","title":"Services","items":[{"url":"#service-interface","title":"Service interface"},{"url":"#provider","title":"Provider"},{"url":"#client","title":"Client"},{"url":"#a-user","title":"A user"},{"url":"#running-the-service","title":"Running the service","items":[{"url":"#jaguar","title":"Jaguar"},{"url":"#local","title":"Local"}]}]},{"url":"#conclusion","title":"Conclusion"}]}]}}},"pageContext":{"title":"Services","id":"874b2bcf-e4f4-53aa-94a5-117e3f89f2c5"}},
    "staticQueryHashes": ["2197327828"]}