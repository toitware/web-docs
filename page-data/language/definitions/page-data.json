{
    "componentChunkName": "component---src-components-layout-mdx-layout-tsx",
    "path": "/language/definitions",
    "result": {"data":{"site":{"siteMetadata":{"title":"Toit documentation"}},"mdx":{"body":"const _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nconst _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"definitions\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#definitions\",\n    \"aria-label\": \"definitions permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Definitions`), mdx(\"h2\", {\n    \"id\": \"library\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#library\",\n    \"aria-label\": \"library permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Library`), mdx(\"p\", null, `A library is a code unit developers can import. There is a one-to-one relationship between a Toit file and a library.`), mdx(\"p\", null, `Libraries can be imported with the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `import`), ` clause.`), mdx(\"h2\", {\n    \"id\": \"sdk-libraries\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#sdk-libraries\",\n    \"aria-label\": \"sdk libraries permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `SDK libraries`), mdx(\"p\", null, `The SDK comes with libraries documented in the `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://libs.toit.io/\"\n  }, `Toit standard libraries`), ` browser.`), mdx(\"p\", null, `The `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://libs.toit.io/core/library-summary\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, `core`), ` module`), ` is automatically\nimported into every file. It contains common classes, like\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://libs.toit.io/core/numbers/class-int\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, `int`)), `,\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://libs.toit.io/core/string/class-string\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, `string`)), `, or\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://libs.toit.io/core/collections/class-List\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, `List`)), `.`), mdx(\"h2\", {\n    \"id\": \"terms\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#terms\",\n    \"aria-label\": \"terms permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Terms`), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, `Locals`), `: a variable which is either declared within the function or is an argument passed to a function, where it is received as a parameter.`)), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, `Globals`), `: a variable declared outside the scope of a function or class. Globals are initialized at first access, and remain alive until the end of the program.`)), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, `Constants`), ` are a special case of globals, defined with a `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `::=`), ` assignment. By convention they have an ALL-CAPS-NAME (see `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../syntax#toit-globals-and-constants\"\n  }, `Toit globals and constants`), `).`))), mdx(\"p\", null, `Within a class, the following items are available: constructors, statics, factories, fields, methods.`), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, `Constructor`), `: a way to construct an object of the given type, always defined by the `, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, `constructor`), ` keyword.\nSee `, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"../objects-constructors-inheritance-interfaces#constructors\"\n  }, `more details here`), `.`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, `Named constructors`), ` allow more than one constructor with the same signature, and often make code more readable.\nSee `, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"../objects-constructors-inheritance-interfaces#named-constructors\"\n  }, `more details here`), `.\nFor example, in the `, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://libs.toit.io/core/string/class-string\"\n  }, `string class`), ` we have a constructor called `, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, `constructor.from-rune rune/int`), `. Thus, when reading the instantiation point `, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, `x := string.from-rune 'X'`), ` it is clear that we construct a string with the character 'X'.`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `A `, mdx(\"strong\", {\n    parentName: \"li\"\n  }, `Factory`), ` is a constructor or named constructor with a return. See an example below and more `, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"../objects-constructors-inheritance-interfaces#factory-constructors\"\n  }, `details here`), `.`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, `Static functions and fields`), `: Static functions and fields are tied to the class rather than individual objects.\nInside a class, static fields and functions are marked with the keyword `, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, `static`), `. Constructors and factories are implicitly static.`)), mdx(\"p\", null, `Static fields are often constants - which can be inferred from their\ncapitalized names, and whether they are final (defined with `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `::=`), `).`), mdx(\"p\", null, `Inside a class, you can refer to static entries directly. Outside the class,\nstatic entries must be prefixed with the class name.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class A:\n  static some-static-field := 499\n  foo:\n    // Inside the class, static entries can be referred to\n    // directly.\n    print some-static-field\n\nmain:\n  // But outside the class, they must be referred to through\n  // the class name:\n  print A.some-static-field\n`)), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, `Methods and instance fields`), `: everything that needs to go through an object.\nMethods without arguments behave similarly to instance fields.`)), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `// Implicitly static, not inside a class, and doesn't\n// require one.\nfoo: print \"foo\"\n\n// Implicitly static, can be accessed without a class.\nsome-global := 499\n\n// A static constant.\nCONSTANT ::= 42\n\nclass A:\n  // Static, as you can write \\`A\\` without creating an \\`A\\`\n  // first.\n  constructor: ...\n\n  // Static, or just a different way to write a constructor.\n  constructor.named:  ...\n\n  // A factory is just a constructor with a \\`return\\`. From\n  // the outside there is no difference to a constructor.\n  constructor.my-factory:\n    return singleton\n\n  // A static field.\n  static singleton ::= A\n\n  // A static function that doesn't require the creation of\n  // an object \\`A\\`.  It's important to see that\n  // \\`A.static-in-A\\` doesn't first create \\`A\\` and then call\n  // \\`static-in-A\\`.  The leading \\`A.\\` is just so we can find\n  // the static function.\n  static static-in-A: print \"static fun\"\n\n  // Same as for the static function: this is a field that\n  // lives independent of an instance.\n  // If you write \\`A.static-field = 1\\` followed by \\`print\n  // A.static-field\\`, then you would get \\`1\\`.  Static fields\n  // are really just like scoped globals.\n  static static-field := 42\n\n  // This non-static method can only be used on an object,\n  // like \\`a := A\\` followed by \\`a.method\\`.\n  method: print \"method\"\n\n  // An instance field.\n  // Operates on an object: \\`a := A\\` followed by \\`a.field =\n  // 42\\` would change the field of the object.  A new,\n  // unmodified, object would again be constructed with\n  // 11 in this field: \\`a2 := A\\` followed by \\`print a2.field\\`\n  // would print 11.\n  field := 11\n\nmain:\n  // Statics can be accessed directly or must be prefixed\n  // with the class name:\n  foo  // Calls foo\n  print some-global  // Prints the global\n  print CONSTANT     // Prints the constant.\n  a := A             // Creates a new A.\n  a2 := A.named      // Creates a new A.\n  a3 := A.my-factory // From the outside the same syntax as\n                     // \\`A.named\\`.\n  A.static-in-A      // Calls the static function *without*\n                     // creating an object first.\n  A.static-field = 11  // Does *not* create an object first.\n  print A.static-field  // Prints the static field 11.\n  a.method           // Invokes the instance method on \\`a\\`.\n  a2.method          // Invokes it on \\`a2\\`.\n  print a.field      // Reads the field in \\`a\\`. => 11\n  a.field = 42       // Only changes the field in \\`a\\`, but\n                     // not a2 or a3.\n  print a.field      // => 42\n  print a2.field     // => 11\n`)), mdx(\"h2\", {\n    \"id\": \"type\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#type\",\n    \"aria-label\": \"type permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Type`), mdx(\"p\", null, `Toit is optionally typed. That is, it is possible, but not required, to annotate variable declarations with types.\nA variable is typed if it is followed by a `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `/`), ` and a type name.\nFor example, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `foo x/y`), ` means the function `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `foo`), ` takes a variable `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `x`), ` with type `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `y`), `.`), mdx(\"p\", null, `By default types are non-nullable, which means null is not a valid\nvalue.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class Coordinate:\n  // An instance field that must be initialized by\n  // constructors.\n  // By writing \\`:= ?\\` we indicate that all constructors\n  // must initialize the field.\n  x /int := ?\n  y /int := ?\n\n  // We don't need to specify the type for constructor\n  // arguments that are written directly to a typed field.\n  constructor .x .y:\n\nmain:\n  a := Coordinate 0 0\n\n  // Error! The types of the fields (and therefore the\n  // constructor arguments) are non-nullable, so null is not\n  // a valid argument here:\n  b := Coordinate null null  // Error!\n`)), mdx(\"p\", null, `If we want a nullable type, we write a question mark `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `?`), ` after the\ntype name. For example in the following `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Foo`), ` class the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `bar`), ` variable can\nbe a reference to an instance of the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Bar`), ` class or interface, but\nit can also be null, which also happens to be the initial value:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class Foo:\n  bar /Bar? := null\n`)), mdx(\"h3\", {\n    \"id\": \"any\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#any\",\n    \"aria-label\": \"any permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Any`), mdx(\"p\", null, `The type name corresponds to the class or interface name of all accepted values.\nIn addition, Toit has `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `any`), ` (for every possible type) and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `none`), ` (when no value is accepted).\nFor example, in the following example `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `rename from/any to/any -> any`), ` , the\nfunction `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `rename`), ` takes 2 arguments: `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `foo`), ` of type `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `any`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `to`), ` of type\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `any`), `.\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `any`), ` is a special type meaning “any” type. It means that the code really works\nfor any input type or that the type-info is missing.`), mdx(\"p\", null, `The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `->`), ` indicates the return type of the function, so `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `foo -> bar`), ` means that the function `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `foo`), ` returns `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `bar`), `.\nThe `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `rename`), ` function in the example `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `rename from/any to/any -> any`), ` returns `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `any`), `.`), mdx(\"p\", null, `In the following example the parameter `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `param`), `, the local `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `my-var`), `, and the\nglobal `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `glob`), ` are all typed in the following example:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `foo param/int:  // The parameter 'param' must be of type int.\n  // The variable 'my-var' is typed as 'float'. The second\n  // '/' is a division.\n  my-var /float := param / 3.14\nglob /string := \"the global 'glob' is typed as string\"\n`)), mdx(\"p\", null, `The type of variable is enforced by the Virtual Machine.\nEvery time a value is stored in the variable, the VM checks that the type is correct.\nIf it isn't, a runtime `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../exceptions\"\n  }, `exception`), ` is thrown.`), mdx(\"p\", null, `Types are also very helpful during development: the IDE can use the typing\ninformation to provide code completion, or warnings when types don't match.`), mdx(\"h3\", {\n    \"id\": \"return-types\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#return-types\",\n    \"aria-label\": \"return types permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Return types`), mdx(\"p\", null, `Functions can also declare their return type by writing `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `->`), ` followed by the return type.\nThe `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `-> type`), ` can be anywhere in the signature, but it's convention to put it\nat the end of the line that declares the name of a function:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `// A function that doesn't return anything.\nfoo -> none:\n  print \"not returning anything\"\n\n// A function that takes an int and returns an int.\nbar x/int -> int:\n  return x + 1\n\ngee with/string  -> float  // Returns a float.\n    arguments / int\n    on / string\n    different / bool\n    --lines:\n  return 3.14\n`)), mdx(\"h3\", {\n    \"id\": \"none\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#none\",\n    \"aria-label\": \"none permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `None`), mdx(\"p\", null, `The return type `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `none`), ` is never needed, as Toit can see whether a method\nreturns something or not. It can, however, help readability of code, and\nprevent developers from accidentally returning a value.`), mdx(\"h3\", {\n    \"id\": \"when-to-write-types\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#when-to-write-types\",\n    \"aria-label\": \"when to write types permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `When to Write Types?`), mdx(\"p\", null, `In a correct program types don't have any effect. As such they are most\nimportant during the development process. Similar to comments, there isn't\nalways a clear-cut rule on when to write code. Different teams don't always\nagree on the \"best\" amount of types.`), mdx(\"p\", null, `We recommend to write types for fields, and in function signatures (parameters\nand return type). This dramatically improves the development experience as the\nIDE can use those types to suggest code completions. This is especially true\nfor functions and variables that are intended to be used by different\ndevelopers. As a general guideline: more users of your code implies you need\nmore types.`), mdx(\"p\", null, `Local variables often don't need explicit types as the IDE can often figure out the type of local variables.\nIf the IDE can't infer the type it is a judgment call whether the type is warranted or not.`));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#definitions","title":"Definitions","items":[{"url":"#library","title":"Library"},{"url":"#sdk-libraries","title":"SDK libraries"},{"url":"#terms","title":"Terms"},{"url":"#type","title":"Type","items":[{"url":"#any","title":"Any"},{"url":"#return-types","title":"Return types"},{"url":"#none","title":"None"},{"url":"#when-to-write-types","title":"When to Write Types?"}]}]}]}}},"pageContext":{"title":"Definitions","id":"43b39614-a457-5f8e-bc40-743067df5118"}},
    "staticQueryHashes": ["2197327828"]}