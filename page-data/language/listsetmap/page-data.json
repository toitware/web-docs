{
    "componentChunkName": "component---src-components-layout-mdx-layout-tsx",
    "path": "/language/listsetmap",
    "result": {"data":{"site":{"siteMetadata":{"title":"Toit documentation"}},"mdx":{"body":"const _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nconst _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return mdx(\"div\", props);\n};\n\nconst Note = makeShortcode(\"Note\");\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"lists-byte-arrays-sets-and-maps\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#lists-byte-arrays-sets-and-maps\",\n    \"aria-label\": \"lists byte arrays sets and maps permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Lists, byte arrays, sets and maps`), mdx(\"p\", null, `The following classes are included in the core SDK as part of the\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://libs.toit.io/core/collections/library-summary\"\n  }, `collections.toit module`), `:`), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `List`), ` provides an ordered and indexed collection which may contain duplicates.\nThis is roughly analogous to extendable arrays in other languages.`), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `ByteArray`), ` is similar to a list for integer elements in the range 0 to 255.\nByte arrays cannot change size, but see `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://libs.toit.io/bytes/class-Buffer\"\n  }, `Buffer`), `\nwhich has a `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `write`), ` method and can be extended.`), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Set`), ` provides a collection of unique objects. When iterating over a `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Set`), `, the\nobjects are processed in insertion order.`), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Map`), ` provides a data structure mapping keys to values. Like `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Set`), `, iteration\nis in insertion order. Overwriting the value associated with a key does not\nchange the order of the key-value pair.`), mdx(\"p\", null, `The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Set`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Map`), ` implementations use hashing to do their operations in\nconstant speed. As a consequence their keys must have a `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `hash-code`), ` member.`), mdx(\"p\", null, `There are two concrete implementations of `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Set`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Map`), `:\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Set`), `/`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Map`), ` use the overwritable `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `==`), ` operator to determine whether two keys\nare equal, whereas `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `IdentitySet`), `/`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `IdentityMap`), ` use `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `identical`), `.`), mdx(\"p\", null, `See some examples of use of `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `List`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Map`), ` in the section `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../blocks-and-lambdas\"\n  }, `Toit blocks`), `.`), mdx(\"p\", null, `See also the documentation for the\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://libs.toit.io/core/collections/class-List\"\n  }, `List`), `,\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://libs.toit.io/core/collections/class-Set\"\n  }, `Set`), `, and\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://libs.toit.io/core/collections/class-Map\"\n  }, `Map`), ` classes.`), mdx(\"p\", null, `The `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../strings\"\n  }, `string`), ` and\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://libs.toit.io/core/collections/class-ByteArray\"\n  }, `ByteArray`), ` classes are\nnot subtypes of\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://libs.toit.io/core/collections/class-Collection\"\n  }, `Collection`), `, but have\nsome similarities to collections.`), mdx(\"h2\", {\n    \"id\": \"set-versus-list-versus-map\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#set-versus-list-versus-map\",\n    \"aria-label\": \"set versus list versus map permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Set versus List versus Map`), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, `Duplicates`), `: A big difference between `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `List`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Set`), ` class is that `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `List`), ` allows duplicates while `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Set`), ` doesn't allow duplicates.\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Map`), ` holds two objects per entry (a key and a value).\nIt may contain duplicate values but keys are always unique.`)), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, `Removing and finding entries`), `: A Set has efficient implementations of\nthe `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `contains`), ` and the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `remove`), ` methods, whereas a List must perform a linear\nsearch or copy operation that depends on the size of the list.`)), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, `Null elements`), `: `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `List`), ` allows null elements. It is possible to have many null\nobjects in a `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `List`), ` because duplicates are allowed.\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Set`), ` does not allow null elements, and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Map`), ` does not allow null keys.`)), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, `Indexing`), `: Lists are designed to allow access to any element by its index.\nSets and maps don't have this ability. Although sets and maps are both\ninsertion-ordered it is not possible to access an arbitrary entry in them\nwith its insertion order. The entries must be\naccessed by lookup or by iterating over all entries. However, Set and Map both have\nmethods `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `first`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `last`), ` that are useful when using them as deduplicating queues or\nFIFOs.`)), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, `Literals`), `: Lists, ByteArrays, Sets and Maps have literals:`))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `list := []\nbyte-array := #[]\nset := {}\nmap := {:}\n`)), mdx(\"p\", null, `These are the preferred short cuts for:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `list := List\nbyte-array := ByteArray 0\nset := Set\nmap := Map\n`)), mdx(\"p\", null, `Literals may also contain values:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `list-with-values := [1, 2, 3]\nbyte-array-with-values := #[1, 2, 3]\nset-with-values := {1, 2}\nmap-with-values := {\n  \"key\": 499,\n  \"key2\": 42,\n}\n`)), mdx(Note, {\n    mdxType: \"Note\"\n  }, mdx(\"p\", null, `Both `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Set`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Map`), ` use hash values to place elements into the underlying data structure.\nThis means that all keys must implement the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `hash-code`), ` method. The performance of sets and\nmaps is best if two different keys have a different hash code (with high probability).`)), mdx(Note, {\n    type: \"warning\",\n    mdxType: \"Note\"\n  }, mdx(\"p\", null, `Sets and Maps only use the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `hash-code`), ` function if their size is big enough. Objects that\ndon't implement `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `hash-code`), ` might thus not yield errors until the collections grow big enough.\nwhere the chance of two different objects having the same hash code should be\nlow.`)), mdx(\"h2\", {\n    \"id\": \"examples-of-using-map\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#examples-of-using-map\",\n    \"aria-label\": \"examples of using map permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Examples of using Map`), mdx(\"p\", null, `Lookup in a map is done with the indexing operator, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `[]`), `:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `  score := scores[team]\n  print \"The score for $team is $score\"\n`)), mdx(\"p\", null, `The index operator syntax is understood by the string interpolation syntax, so you can simply write:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `  print \"The score for $team is $scores[team]\"\n`)), mdx(\"p\", null, `Updating or adding to a map is done with the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `[]=`), ` operator:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `graduate name/string:\n  title-map[name] = \"PhD\"\n`)), mdx(\"p\", null, `The index operator, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `[]`), ` requires the key to be present in the map, otherwise\nit throws an `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../exceptions\"\n  }, `exception`), `. As an alternative, you can use the\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `get`), ` method which\nby default returns null for a missing key:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class Scoring:\n  // scorers is a map where the key is a team and the value\n  // is a set of those that have scored goals for the team.\n  scorers /Map ::= {:}\n\n  register-goal team/string new-scorer/string -> none:\n    goal-scorers /Set? := scorers.get team\n    if goal-scorers == null:\n      // First time the team scores, there is no set of\n      // goal scorers in the map.  We insert an empty set\n      // into which we can insert the new goal scorer.\n      goal-scorers = {}  // Empty set.\n      scorers[team] = goal-scorers\n    goal-scorers.add new-scorer\n`)), mdx(\"p\", null, `Often there are more succinct ways to achieve the same with variations of the\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `get`), ` method. The above could be written:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `  register-goal team/string new-scorer/string -> none:\n    // Get the set of goal-scorers for this team,\n    // initializing with the empty set if necessary.\n    goal-scorers /Set := scorers.get team --init=: {}\n    goal-scorers.add new-scorer\n`)), mdx(\"p\", null, `The full set of map methods is available in the `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://libs.toit.io/core/collections/class-Map\"\n  }, `class\ndocumentation`), `. See also the\nguide to `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../blocks-and-lambdas#calling-functions-with-named-block-parameters\"\n  }, `using named block\nparameters`)), mdx(\"h2\", {\n    \"id\": \"functional-methods\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#functional-methods\",\n    \"aria-label\": \"functional methods permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Functional methods`), mdx(\"p\", null, `Toit contains a full set of the collection methods like `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `map`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `reduce`), ` which\nare known from functional languages. Often you can use these instead of explicitly\niterating over the collection.`), mdx(\"p\", null, `Instead of:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `report-odd collection/List:\n  found := false\n  collection.do:\n    if it % 2 == 1:\n      found = true\n  if found:\n    print \"The collection contains at least one odd number\"\n`)), mdx(\"p\", null, `You can use the `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://libs.toit.io/core/collections/class-Collection#any(1%2C1%2C0%2C)\"\n  }, `any`), `\nmethod, which also has the advantage that it stops\nwhen it has found a object in the collection which fulfills the predicate:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `  if (collection.any: it % 2 == 1):\n    print \"The collection contains at least one odd number\"\n`)), mdx(\"p\", null, `(In this case we added parentheses around the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `if`), `-condition so the colon that\nintroduces the block argument to `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `any`), ` does not get mistaken for the colon of the\nif-statement. The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `any`), ` method is often called `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `some`), ` in functional languages.)`), mdx(\"p\", null, `Both of these examples made use of the\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../blocks-and-lambdas#block-arguments\"\n  }, `automatic block argument, `, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, `it`)), `.`), mdx(\"p\", null, `Similarly, Toit collections have the\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://libs.toit.io/core/collections/class-Collection#every(1%2C1%2C0%2C)\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, `every`)), `\nmethod known from functional languages:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `  if (collection.every: it % 2 == 1):\n    print \"The collection contains only odd numbers\"\n`)), mdx(\"p\", null, `The reduce method:`), mdx(\"p\", null, `(The example shows the use of a\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../blocks-and-lambdas\"\n  }, `block`), ` with `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../blocks-and-lambdas#block-arguments\"\n  }, `two named\narguments`), `).`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `  sum := collection.reduce: | a b | a + b\n`)), mdx(\"p\", null, `This only works if the collection has at least one element and that element is\na good starting point for the reduction operation. Otherwise you need to add\nthe optional `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `--initial`), ` argument. For example in the following example the\nelements of the collection are integers, but the result of the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `reduce`), `\noperation has a different type, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `float`), `.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `sum-of-roots collection/Collection -> float:\n  return collection.reduce --initial=0.0: | sum-so-far integer |\n    sum-so-far + integer.sqrt\n`)), mdx(\"p\", null, `The version of `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `reduce`), ` with an initial value is called `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `fold`), ` in functional\nlanguages.`), mdx(\"p\", null, `Similarly the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `List`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Set`), ` classes have `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `map`), `:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `// Creates a comma-separated list of quoted strings.\ncsv list/List -> string:\n  Q ::= \"\\\\\"\"  // A double quote.\n  if (list.any: it.contains Q):\n    throw \"Can't handle strings containing quotes\"\n  quoted-list := list.map: \"$Q$it$Q\"\n  return quoted-list.join \",\"\n`)), mdx(\"p\", null, `A more advanced version would handle strings containing quotes:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `// Creates a comma-separated list of quoted strings,\n// escaping quotes.\ncsv list/List -> string:\n  Q ::= \"\\\\\"\"  // A double quote.\n  escaped-list := list.map:\n    str := \"$it\"\n    if str.contains Q:\n      // In CSV quotes are escaped as two quotes.\n      str.replace --all Q \"$Q$Q\"\n    else:\n      str\n  quoted-list := escaped-list.map: \"$Q$it$Q\"\n  return quoted-list.join \",\"\n`)), mdx(\"p\", null, `That example also illustrates that the value of the block (returned to the\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `map`), ` method) is the result of the last statement. In this case one of the\nbranches of the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `if`), ` will be the last statement, producing the return value.\nAn alternative way to do this would be to use\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../blocks-and-lambdas#local-return\"\n  }, `continue.map`)), mdx(\"p\", null, `We could also reduce it to an almost unreadable one-liner by putting an\narbitrary expression in a string interpolation, surrounding it with `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `$(`), ` and\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `)`), `:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `// Creates a comma-separated list of quoted strings,\n// escaping quotes.\ncsv list/List -> string:\n  return (list.map: \"\\\\\"$(\"$it\".replace --all \"\\\\\"\" \"\\\\\"\\\\\"\")\\\\\"\").join \",\"\n`)), mdx(\"h2\", {\n    \"id\": \"sorting\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#sorting\",\n    \"aria-label\": \"sorting permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Sorting`), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `sort`), ` is a method of the class `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://libs.toit.io/core/collections/class-List\"\n  }, `List`), `.`), mdx(\"p\", null, `To sort a list of numbers from biggest to smallest number and extract the smallest number`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  list := [3, 2, 5, 1]\n  sorted := list.sort\n  print sorted[0]\n`)), mdx(\"p\", null, `If the list should be sorted in place, avoiding the allocation of a fresh list`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  list := [3, 2, 5, 1]\n  list.sort --in-place\n  print list.first\n`)), mdx(\"p\", null, `To get the highest number of the sorted list`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `  print list.last\n`)), mdx(\"p\", null, `It is also possible to sort with a custom comparison by passing a block to the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `sort`), ` function`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  my-list := [1, 2, 5, 9]\n  my-list.sort --in-place: | a b | b - a\n  print my-list[0]\n`)), mdx(\"p\", null, `The block takes two arguments, which are here called `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `a`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `b`), ` and should\nreturn (implicitly) a value that can be negative, zero, or positive.\nNote that `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `b - a`), ` sorts in descending order.`));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#lists-byte-arrays-sets-and-maps","title":"Lists, byte arrays, sets and maps","items":[{"url":"#set-versus-list-versus-map","title":"Set versus List versus Map"},{"url":"#examples-of-using-map","title":"Examples of using Map"},{"url":"#functional-methods","title":"Functional methods"},{"url":"#sorting","title":"Sorting"}]}]}}},"pageContext":{"title":"Lists, byte arrays, sets and maps","id":"7fce8ab7-551c-5bb1-839f-449870a40377"}},
    "staticQueryHashes": ["2197327828"]}