{
    "componentChunkName": "component---src-components-layout-mdx-layout-tsx",
    "path": "/language/objects-constructors-inheritance-interfaces",
    "result": {"data":{"site":{"siteMetadata":{"title":"Toit documentation"}},"mdx":{"body":"const _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nconst _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"classes\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#classes\",\n    \"aria-label\": \"classes permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Classes`), mdx(\"p\", null, `In Toit, everything is an object, including things that may be non-object\n\"primitive types\" in other languages. For example, an `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../math\"\n  }, `integer`), `\nis an object, and has methods like `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `abs`), `:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `// Method that takes an \\`int\\` and returns an \\`int\\`.\nfoo x/int -> int:\n  return x.abs  // The absolute value of x.\n`)), mdx(\"p\", null, `To create custom objects, we must first define a class:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class Point:\n  x /int := 42\n  y /int := 103\n`)), mdx(\"p\", null, `Here we have given our new class two fields, with integer\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../definitions#type\"\n  }, `types`), `, and they are\nby default initialized to 42 and 103. We create new instance objects of the\nclass by naming the class, no `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `new`), ` keyword is needed:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  p := Point  // Creates a new Point object\n  print p.x  // >> 42\n  print p.y  // >> 103\n`)), mdx(\"p\", null, `There are various ways to declare fields in objects:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class Foo:\n  // u is untyped and initialized to zero.\n  u := 0\n  // v is an integer.\n  v /int := 0\n  // w is a nullable integer (either null or an integer).\n  w /int? := null\n  // x is an integer, and it must be set by the constructor.\n  x /int := ?\n  // y is an integer, the field is immutable, the\n  // constructor must set it.\n  y /int\n  // z has the same properties as y, but the short form is\n  // better style.\n  z /int ::= ?\n  // LTUAE is a constant.  When possible, prefer static\n  // constants.\n  LTUAE /int ::= 42\n  // PASSWORD is a static constant.\n  static PASSWORD /string ::= \"hunter2\"\n\n  constructor:\n    x = y = z = 0   // Set the fields that must be set.\n`)), mdx(\"h2\", {\n    \"id\": \"getters-and-setters\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#getters-and-setters\",\n    \"aria-label\": \"getters and setters permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Getters and Setters`), mdx(\"p\", null, `In Toit the external syntax for getters and setters is\nthe same as for public fields:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class Bar:\n  x /int := ?\n\n  constructor .x:\n\nmy-function bar/Bar -> none:\n  // Accesses public field x, or uses the x getter.\n  print bar.x\n\n  // Sets the public field x, or uses the x setter.\n  bar.x = 42\n`)), mdx(\"p\", null, `If we later decide to make the x field private we rename it to have a final\nunderscore. At the same time, we can introduce getters and setters that keep\nour class compatible with the old version:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class Bar:\n  x_ /int := ? // Private field.\n\n  constructor .x_:\n\n  // Getter, returns an int.\n  x -> int:\n    return x_\n\n  // Setter, takes an int, returns nothing.\n  x= value/int -> none:\n    x_ = value\n    print \"x_ was set to $x_\"\n`)), mdx(\"h2\", {\n    \"id\": \"inheritance\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#inheritance\",\n    \"aria-label\": \"inheritance permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Inheritance`), mdx(\"p\", null, `Toit is an object-oriented language. The inheritance and typing\nmechanism for classes is similar to the one of Java: Classes can\nextend each other, with subclasses being subtypes in the typing\nsystem.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class Point:\n  x /int := 0\n  y /int := 0\n\nclass Point3D extends Point:\n  z /int := 0\n\nmain:\n  p /Point? := null  // Local variable p has type Point (nullable).\n  p = Point          // Create point.\n  // Since a Point3D is a type of point we can\n  // assign p to refer to a Point3D.\n  p = Point3D        // Create 3d point.\n  p.x = 42           // OK because Point has a field called x.\n  p.z = 103          // Compile-time error: Point has no z field!\n  p3 := p as Point3D // Cast p to a Point3D (with run-time check).\n  p3.z = 103         // OK because p3 has the right static type.\n`)), mdx(\"h3\", {\n    \"id\": \"interfaces\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#interfaces\",\n    \"aria-label\": \"interfaces permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Interfaces`), mdx(\"p\", null, `A class can only extend one class, but can implement several\ninterfaces. Like classes, interfaces act as `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../definitions#type\"\n  }, `types`), `\nin Toit's type\nsystem, but unlike classes, they do not include implementations for\nthe non-static methods they declare. Since a method signature declared in an\ninterface has no implementation, the colon at the end of the first\nline is omitted:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `// To implement the Turtle interface, a class must have\n// these two methods.\ninterface Turtle:\n  forwards mm/int -> none\n  turn degrees/int -> none\n\n// To be used as a Drawable, a class must have a method\n// called draw, which takes a Turtle and returns no value.\ninterface Drawable:\n  // No colon on the method declaration\n  draw turtle/Turtle -> none\n\n// To have the type \\`Drawable\\` the Square class must both\n// declare that it \\`implements Drawable\\`, and contain the\n// \\`draw\\` method.\nclass Square implements Drawable:\n  draw turtle/Turtle -> none:\n    4.repeat:\n      turtle.forwards 10\n      turtle.turn 90\n\nmain:\n  // Variables can have interface types.  Here \\`d\\` has the\n  // type \\`Drawable\\`.\n  d /Drawable := Square\n`)), mdx(\"p\", null, `In Toit an interface can have static methods and constructors,\nbut the constructors must be `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#factory-constructors\"\n  }, `factory constructors`), `.`), mdx(\"p\", null, `An abstract class has some similarities to a class and to an\ninterface. Like a class, it can have fields and methods that\nits extending classes will inherit. Like an interface, it can\nhave methods without implementations and constructors. The class and the\nnon-static methods must be marked explicitly as abstract. A class cannot\nbe instantiated (objects of that class cannot be created) unless\nit implements all the required methods from the abstract classes\nit extends:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `// Classes that extend \\`TurtleBase\\` must implement two\n// methods.\nabstract class TurtleBase:\n  mileage := 0\n\n  // Classes that extend \\`TurtleBase\\` should call this after\n  // moving a distance to register the distance the Turtle\n  // has moved.\n  register-mileage mm/int -> none:\n    mileage += mm\n\n  // Concrete (non-abstract) classes that extend TurtleBase\n  // must implement these two methods.\n  abstract forwards mm/int -> none\n  abstract turn degrees/int -> none\n\n// The LogTurtle doesn't actually perform the drawing moves,\n// it just logs the moves a real turtle would make.\nclass LogTurtle extends TurtleBase:\n  forwards mm/int -> none:\n    print \"I moved forwards $(mm)mm.\"\n    register-mileage mm\n\n  turn degrees/int -> none:\n    print \"I turned $degrees degrees\"\n\nmain:\n  turtle := LogTurtle\n  4.repeat:\n    turtle.forwards 10  // >> I moved forwards 10mm.\n    turtle.turn 90      // >> I turned 90 degrees.\n  print \"The turtle has travelled $(turtle.mileage)mm.\"\n`)), mdx(\"h2\", {\n    \"id\": \"constructors\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#constructors\",\n    \"aria-label\": \"constructors permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Constructors`), mdx(\"p\", null, `Sometimes it is not enough to specify the initial values for fields. When there\nare more complex ways to initialize an object we make use of special functions\ncalled constructors. In Toit the constructor has the name `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `constructor`), ` rather\nthan having the same name as the class:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `import math\n\nclass Vector:\n  x /float\n  y /float\n  length /float\n\n  constructor x-arg/float y-arg/float:\n    x = x-arg\n    y = y-arg\n    length = math.sqrt x * x + y * y\n`)), mdx(\"p\", null, `It is rather common that parameters of constructors are copied directly into\nfields of the new object, so there is a shorthand. By putting a dot (`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `.`), `) in\nfront of the parameter name, it is copied directly to the field of the same\nname:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `import math\n\nclass Vector:\n  x /float\n  y /float\n  length /float\n\n  // The dots initialize fields x and y.  No need to restate\n  // the types of x and y here.\n  constructor .x .y:\n    length = math.sqrt x * x + y * y\n`)), mdx(\"p\", null, `The shorthand `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `.field`), ` parameter has the same type as the field it assigns to.`), mdx(\"h3\", {\n    \"id\": \"named-constructors\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#named-constructors\",\n    \"aria-label\": \"named constructors permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Named Constructors`), mdx(\"p\", null, `By default, constructors have no name and are invoked with\nthe name of the class. For example, the above unnamed constructor for the\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Vector`), ` class is invoked using the name `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Vector`), `:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  // Create a new Vector using the unnamed constructor.\n  // Note that there is no \\`new\\` keyword in Toit.\n  v := Vector 10.0 7.5\n`)), mdx(\"p\", null, `We can have several unnamed constructors with different numbers of arguments.\nThis is a natural result of the fact that Toit has argument-count\noverloading and argument-name overloading.`), mdx(\"p\", null, `However, sometimes it is more helpful to have constructors with different\nnames. For example, the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Vector`), ` class might have a polar constructor:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `import math\n\nclass Vector:\n  x /float\n  y /float\n  length /float\n\n  constructor .x .y:\n    length = math.sqrt x * x + y * y\n\n  constructor.polar angle/float .length:\n    // The dot above initializes the length field.\n    x = length * (math.cos angle)\n    y = length * (math.sin angle)\n\nmain:\n  // Use the unnamed Cartesian constructor.\n  v := Vector 10.0 7.5\n  // Use the polar constructor.\n  v2 := Vector.polar math.PI/6 8.0\n`)), mdx(\"h3\", {\n    \"id\": \"super-constructors\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#super-constructors\",\n    \"aria-label\": \"super constructors permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Super-constructors`), mdx(\"p\", null, `In a class with inheritance you may want to invoke a constructor\nfor the class you are extending. This is done with the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `super`), ` keyword:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class Color:\n  r /int\n  g /int\n  b /int\n\n  constructor .r .g .b:\n\nclass ColoredVector extends Vector:\n  color /Color\n\n  constructor x/float y/float .color:\n    super x y  // Calls the constructor of \\`Vector\\`.\n`)), mdx(\"h3\", {\n    \"id\": \"factory-constructors\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#factory-constructors\",\n    \"aria-label\": \"factory constructors permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Factory constructors`), mdx(\"p\", null, `A factory constructor is rather like a static method\nthat returns an instance of the class. Simply placing\na return statement in a constructor makes it into a\nfactory constructor.`), mdx(\"p\", null, `For example, it may be very common to create a special\ninstance of an immutable class. Since it is immutable,\nthe constructor can save memory by returning the same\nobject every time. Here we have a factory constructor\nnamed `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `origin`), `.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class Pair:\n  x /int\n  y /int\n\n  // Regular constructor.\n  constructor .x .y:\n\n  // Private singleton object.\n  static SINGLETON-ORIGIN_ ::= Pair 0 0\n\n  // Named factory constructor.\n  constructor.origin:\n    return SINGLETON-ORIGIN_\n`)), mdx(\"p\", null, `Factory constructors are the only kinds of constructors\nthat interfaces can have. You cannot instantiate an\ninterface, so regular constructors are not possible. An\nexample of this is ByteArray, which is actually an\ninterface because there are several different implementations.\nThe constructors return a \"regular\" ByteArray:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `  ba1 := ByteArray 10         // Constructs a ByteArray with 10 zeros.\n  ba2 := ByteArray 5: it * 2  // Constructs #[0, 2, 4, 6, 8]\n`)), mdx(\"h3\", {\n    \"id\": \"advanced-constructor-topics\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#advanced-constructor-topics\",\n    \"aria-label\": \"advanced constructor topics permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Advanced constructor topics`), mdx(\"p\", null, `Some languages have a different syntax for initializing the\nfield variables. For example, C++ has the\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.cppreference.com/w/cpp/language/constructor\"\n  }, `initializer list`), `\nwhich can precede the constructor body. In Dart a similar feature\nis also called `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://dart.dev/guides/language/language-tour#constructors\"\n  }, `initializer\nlists`), `.\nToit uses the same syntax for member initialization\nas for the rest of the constructor, so you don't have to learn two\ndifferent syntaxes.`), mdx(\"p\", null, `Usually you don't have to worry about where the boundary is between\nfield initialization and the rest of the constructor, but there can\nbe situations where it matters. Implicitly, a constructor is split into two\nparts: the initialization, and the instance part. They are separated by the\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `super`), ` call.\nIf no `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `super`), ` call is present, then Toit implicitly adds\none as late as possible. This is either at the end of the constructor body, or\nas soon the code uses `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `this`), `, a reference to the newly constructed object.\nImplicit uses of `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `this`), ` also count, for example by invoking a method, or by\ncreating a `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../tasks\"\n  }, `lambda`), ` that captures `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `this`), `.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class Point:\n  x/float // This must be set during field initialization...\n  y/float // ...of the constructor.\n\n  // A method on the Point class\n  stringify -> string:\n    return \"$x, $y\"\n\n  constructor x-arg/float y-arg/float:\n    // Calling the stringify method uses \"this\".\n    print \"Created \" + stringify\n    x = x-arg  // Error - this happens in the instance...\n    y = y-arg  // ...part of the constructor.\n`)), mdx(\"p\", null, `Although the compiler will infer the boundary between field\ninitialization and object creation you can always explicitly specify\nit by calling the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `super`), ` constructor. Even classes that don't\nexplicitly extend another class extend the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Object`), ` class so\nyou can call the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `super`), ` constructor with no arguments:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class Foo:\n  x /int\n  constructor:\n    x = 12\n    // Explicit 'super' calls are possible but rare.\n    super\n    // Explicit \\`this\\` is also not normally needed.\n    print this.x\n`)), mdx(\"p\", null, `Before the object is created you can already refer to fields that\nhave been assigned. These field accesses do not count as instance accesses.\nImmutable fields do not become immutable before the call to `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `super`), `\nin the constructor..\nThis still means the fields are immutable all other places than in the\nconstructor, since no other parts of the program can obtain a reference\nto the newly constructed object before the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `super`), ` call.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `import math\n\nclass Vector:\n  x/float  // These must be initialized in the initializer...\n  y/float  // ...part of the constructor, not later.\n  length /float\n\n  // A method on the Vector class\n  stringify -> string:\n    return \"$x, $y\"\n\n  constructor.unit:\n    x = 1.0\n    y = 1.0\n    // It is OK to access fields in the initializer part of\n    // the constructor.\n    length = math.sqrt x * x + y * y\n    super\n    // Implicit use of this when calling stringify.\n    print stringify\n`)));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#classes","title":"Classes","items":[{"url":"#getters-and-setters","title":"Getters and Setters"},{"url":"#inheritance","title":"Inheritance","items":[{"url":"#interfaces","title":"Interfaces"}]},{"url":"#constructors","title":"Constructors","items":[{"url":"#named-constructors","title":"Named Constructors"},{"url":"#super-constructors","title":"Super-constructors"},{"url":"#factory-constructors","title":"Factory constructors"},{"url":"#advanced-constructor-topics","title":"Advanced constructor topics"}]}]}]}}},"pageContext":{"title":"Classes","id":"118b15ea-0e27-52a6-8c8d-4e6c4ca41de3"}},
    "staticQueryHashes": ["2197327828"]}