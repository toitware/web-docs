{
    "componentChunkName": "component---src-components-layout-mdx-layout-tsx",
    "path": "/language/bitmask",
    "result": {"data":{"site":{"siteMetadata":{"title":"Toit documentation"}},"mdx":{"body":"const _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nconst _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"bitwise-operations\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#bitwise-operations\",\n    \"aria-label\": \"bitwise operations permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Bitwise operations`), mdx(\"p\", null, `Many devices have registers. These are a small number of\nbinary numbers stored in the device and used to control\nthe device or read its sensors.`), mdx(\"p\", null, `Often, several values are stored in one register. This\nmeans we have to do some programming to manipulate the\nseparate values stored together in one register. For\nexample a display may have an adjustable brightness and\nand adjustable contrast. These may be stored together\nin one register.`), mdx(\"p\", null, `The problem arises when we have primitives to read or\nwrite an entire register, but we only want to read or\nwrite one of the values stored in the register.`), mdx(\"p\", null, `For this we use a binary \"mask\".\nThe mask indicates with '1' or '0' which bits we want to\nprocess. Mostly people use '1' to indicate the\nbits that should be processed, but\neither works. You just have to know which you are using.`), mdx(\"p\", null, `Before we can explain the use of a mask we have to\nexplain the bitwise boolean operations.`), mdx(\"h2\", {\n    \"id\": \"the-and-operation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#the-and-operation\",\n    \"aria-label\": \"the and operation permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `The \"and\" operation`), mdx(\"p\", null, `The boolean bitwise \"and\" operation is an operation on\ntwo binary numbers that gives a result. It is written:`), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `result = left & right`)), mdx(\"p\", null, `For each position in the binary number, the result is\n'1' only if both the inputs have '1' in that position.\nSo:`), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, `0 & 0 == 0`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `0 & 1 == 0`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `1 & 0 == 0`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `1 & 1 == 1`)), mdx(\"p\", null, `For a single digit binary number the \"&\" operation is\nlike multiplication, usually written with \"`, `*`, `\" on\ncomputers.`), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, `0 `, `*`, ` 0 == 0`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `0 `, `*`, ` 1 == 0`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `1 `, `*`, ` 0 == 0`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `1 `, `*`, ` 1 == 1`)), mdx(\"p\", null, `We can use the bitwise \"and\" operation with a mask value\nas follows. Let's say we want to change bits 3 to 7 in\na value (bits are counted from the right, starting with\n0). We can make a mask that has ones in positions 3 to 7. Binary numbers are written with 0b in Toit, and we\ncan insert underscores anywhere we want to improve\nreadability.`), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `MASK := 0b000000000_1111_000`)), mdx(\"p\", null, `This mask value has zeros everywhere except in the area\nwe are interested in, positions 3 to 7. For every mask\nthere is the opposite mask, with all the bits reversed:`), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `ANTI-MASK ::= 0b111111111_0000_111`)), mdx(\"p\", null, `If we have one mask, we can make the other one with the\ntilde (~) operator:`), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `ANTI-MASK ::= ~MASK // This does the same.`)), mdx(\"p\", null, `Now if we want to change the bits 3-7 in a value to\nbe 1010 regardless of what they were before we start\nby zeroing bits 3-7. This can be done with the\nanti-mask:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `// This can also be written:  value &= ANTI-MASK\nvalue = value & ANTI-MASK\n`)), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, `value      101010101_0101_010\nantimask   111111111_0000_111\n           ------------------  & operation (\"and\")\nnew value  101010101_0000_010\n                     ^^^^------- the zeroed bits are here.\n`)), mdx(\"p\", null, `The masking operation has zeroed the bits from 3-7, while the\nother bits in the value are untouched.`), mdx(\"h2\", {\n    \"id\": \"the-or-operation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#the-or-operation\",\n    \"aria-label\": \"the or operation permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `The \"or\" operation`), mdx(\"p\", null, `To set the bits to a desired value, we use the \"or\" operation\nwhich is the pendant to the \"and\" operation, and is written\nwith the vertical pipe sign \"|\".`), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, `0 | 0 == 0`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `0 | 1 == 1`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `1 | 0 == 1`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `1 | 1 == 1`)), mdx(\"p\", null, `Let's say we want to set bits 3-7 to 1100. We would use\nan \"or\" operation on a number with the bits in that place\nand zeroes in all other places.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `value = value | 0b000000000_1100_000\n`)), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, `new value  101010101_0000_010\nnumber     000000000_1100_000\n           ------------------  | operation (\"or\")\nnew2 value 101010101_1100_010\n                     ^^^^------ the 1100 has been inserted here.\n`)), mdx(\"h2\", {\n    \"id\": \"putting-it-all-together\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#putting-it-all-together\",\n    \"aria-label\": \"putting it all together permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Putting it all together`), mdx(\"p\", null, `Perhaps we have a device with an 8-bit register that has two fields.\nThe low 4 bits control brightness, and the high 4 control contrast.\nThere are some constants:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `BRIGHTNESS-0 ::= 0b0000\nBRIGHTNESS-1 ::= 0b0001\nBRIGHTNESS-2 ::= 0b0010\nBRIGHTNESS-3 ::= 0b0011\nBRIGHTNESS-4 ::= 0b0100\nBRIGHTNESS-5 ::= 0b0101\nBRIGHTNESS-6 ::= 0b0110\nBRIGHTNESS-7 ::= 0b0111\nBRIGHTNESS-8 ::= 0b1000\nBRIGHTNESS-9 ::= 0b1001\nBRIGHTNESS-10 ::= 0b1010\nBRIGHTNESS-11 ::= 0b1011\nBRIGHTNESS-12 ::= 0b1100\nBRIGHTNESS-13 ::= 0b1101\nBRIGHTNESS-14 ::= 0b1110\nBRIGHTNESS-15 ::= 0b1111\n\nCONTRAST-0 ::=  0b0000_0000\nCONTRAST-1 ::=  0b0001_0000\nCONTRAST-2 ::=  0b0010_0000\nCONTRAST-3 ::=  0b0011_0000\nCONTRAST-4 ::=  0b0100_0000\nCONTRAST-5 ::=  0b0101_0000\nCONTRAST-6 ::=  0b0110_0000\nCONTRAST-7 ::=  0b0111_0000\nCONTRAST-8 ::=  0b1000_0000\nCONTRAST-9 ::=  0b1001_0000\nCONTRAST-10 ::= 0b1010_0000\nCONTRAST-11 ::= 0b1011_0000\nCONTRAST-12 ::= 0b1100_0000\nCONTRAST-13 ::= 0b1101_0000\nCONTRAST-14 ::= 0b1110_0000\nCONTRAST-15 ::= 0b1111_0000\n`)), mdx(\"p\", null, `We only have the operations `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `read_register`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `write_register`), `,\nbut we want to adjust the two values independently:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class MyDevice extends OneRegisterDevice:\n\n  // Constructor...\n\n  get-brightness -> int:\n    reg := read-register\n    return reg & BRIGHTNESS-MASK_\n\n  get-contrast -> int:\n    reg := read-register\n    return reg & CONTRAST_MASK_\n\n  set-brightness brightness/int -> none:\n    reg := read-register\n    // Remove the old brightness with the mask.\n    reg &= ~BRIGHTNESS-MASK_\n    // Insert the new brightness with the \"or\" operation.\n    reg |= brightness\n    // Write back the old contrast and the new brightness.\n    write-register reg\n\n  set-contrast contrast/int -> none:\n    reg := read-register\n    // Remove the old brightness with the mask.\n    reg &= ~CONTRAST-MASK_\n    // Insert the new contrast with the \"or\" operation.\n    reg |= contrast\n    // Write back the new contrast and the old brightness.\n    write-register reg\n\n  BRIGHTNESS-MASK_ ::= 0b0000_1111\n  CONTRAST-MASK_   ::= 0b1111_0000\n`)), mdx(\"h2\", {\n    \"id\": \"using-the-shift-operations\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#using-the-shift-operations\",\n    \"aria-label\": \"using the shift operations permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Using the shift operations`), mdx(\"p\", null, `In the example above, the user of the driver could choose between\n16 discrete contrast levels, but perhaps the user wants to do\na calculation. In that case they have perhaps calculated number\nbetween 0 and 15, and would like to use that. We can do that\nwith the help of the shift operators, \"<<\" and \">>\".`), mdx(\"p\", null, `The shift operations move the bits of a binary number around.\nFor example, the \">>\" operator moves them to the right.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `value :=        0b00101000000\nvalue = value >> 3\n// Now value == 0b00000101000\nvalue <<= 4\n// Now value == 0b01010000000\n`)), mdx(\"p\", null, `Using this operation we could rewrite our MyDevice to take\nvalues from 0 to 15 instead of the constants:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class MyDevice extends OneRegisterDevice:\n  // Constructors...\n\n  /// Get the current brightness from 0-15.\n  get-brightness -> int:\n    reg := read-register\n    return (reg & BRIGHTNESS-MASK_) >> BRIGHTNESS-SHIFT_\n\n  /// Get the current contrast from 0-15.\n  get-contrast -> int:\n    reg := read-register\n    return (reg & CONTRAST-MASK_) >> CONTRAST-SHIFT_\n\n  /// Set the current brightness from 0-15.\n  set-brightness brightness/int -> none:\n    assert: 0 <= brightness <= 15\n    reg := read-register\n    // Remove the old brightness with the mask.\n    reg &= ~BRIGHTNESS-MASK_\n    // Insert the new brightness with the \"or\" operation.\n    reg |= brightness << BRIGHTNESS-SHIFT_\n    // Write back the old contrast and the new brightness.\n    write-register reg\n\n  /// Set the current contrast from 0-15.\n  set-contrast contrast/int -> none:\n    assert: 0 <= contrast <= 15\n    reg := read-register\n    // Remove the old contrast with the mask.\n    reg &= ~CONTRAST-MASK_\n    // Insert the new contrast with the \"or\" operation.\n    reg |= contrast << CONTRAST-SHIFT_\n    // Write back the new contrast and the old brightness.\n    write-register reg\n\n  // The brightness is stored in the low 4 bits, and the\n  // contrast is stored in the high 4 bits.\n  BRIGHTNESS-MASK_  ::= 0b0000_1111\n  CONTRAST-MASK_    ::= 0b1111_0000\n  BRIGHTNESS-SHIFT_ ::= 0\n  CONTRAST-SHIFT_   ::= 4\n`)));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#bitwise-operations","title":"Bitwise operations","items":[{"url":"#the-and-operation","title":"The \"and\" operation"},{"url":"#the-or-operation","title":"The \"or\" operation"},{"url":"#putting-it-all-together","title":"Putting it all together"},{"url":"#using-the-shift-operations","title":"Using the shift operations"}]}]}}},"pageContext":{"title":"Bitwise operations","id":"956fd626-1680-5eec-bc33-bde60f5e8265"}},
    "staticQueryHashes": ["2197327828"]}