{
    "componentChunkName": "component---src-components-layout-mdx-layout-tsx",
    "path": "/language",
    "result": {"data":{"site":{"siteMetadata":{"title":"Toit documentation"}},"mdx":{"body":"const _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nconst _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return mdx(\"div\", props);\n};\n\nconst Tabs = makeShortcode(\"Tabs\");\nconst Tab = makeShortcode(\"Tab\");\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"language-basics\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#language-basics\",\n    \"aria-label\": \"language basics permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Language basics`), mdx(\"p\", null, `This quick-start guide is inspired by `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.ruby-lang.org/en/documentation/quickstart/\"\n  }, `Ruby in Twenty\nMinutes`), `. It makes the\nassumption that you have `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../getstarted/device\"\n  }, `Jaguar installed`), `\non your machine.`), mdx(\"p\", null, `Toit is an `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/toitlang/toit\"\n  }, `open source`), `, `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./objects-constructors-inheritance-interfaces\"\n  }, `object-oriented`), `\nprogramming language for the Internet of Things. The Toit language has the following desirable properties:`), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, `Modern, simple, and approachable`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `High-level and object-oriented`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `Declarative and statically analyzable`), mdx(\"li\", {\n    parentName: \"ul\"\n  }, `Safe and garbage collected`)), mdx(\"p\", null, `Now, let's get started with some programming!`), mdx(\"h2\", {\n    \"id\": \"hello-world\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#hello-world\",\n    \"aria-label\": \"hello world permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Hello, World`), mdx(\"p\", null, `The Toit SDK and Jaguar CLI both support running small programs directly from the command line.\nIf you put the following code in a file called `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `hello.toit`), `:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  print \"Hello World!\"\n`)), mdx(\"p\", null, `you can run it from the command line like this:`), mdx(Tabs, {\n    mdxType: \"Tabs\"\n  }, mdx(Tab, {\n    label: \"Jaguar\",\n    mdxType: \"Tab\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-txt\"\n  }, `$ jag run -d host hello.toit\nHello World!\n`)), mdx(\"p\", null, `What just happened? The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `jag`), ` command line tool read your source code\n(`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `hello.toit`), `) and started running it from the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `main`), ` method that you defined.\nThe `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `main`), ` method consists of all the indented statements just below the method\ndeclaration line `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `main:`), `. Toit is indentation-based like Python, so the spaces\nyou add to your programs are significant.`)), mdx(Tab, {\n    label: \"toitlang.org\",\n    mdxType: \"Tab\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-txt\"\n  }, `$ toit.run hello.toit\nHello World!\n`)), mdx(\"p\", null, `What just happened? The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `toit.run`), ` command line tool read your source code\n(`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `hello.toit`), `) and started running it from the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `main`), ` method that you defined.\nThe `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `main`), ` method consists of all the indented statements just below the method\ndeclaration line `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `main:`), `. Toit is indentation-based like Python, so the spaces\nyou add to your programs are significant.`))), mdx(\"p\", null, `Once the program ran, it printed `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Hello World!`), ` in your terminal. This is\nbecause the only statement in `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `hello.toit`), ` is a method call, where you invoke\nthe `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `print`), ` method with a single argument, which is the `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./strings\"\n  }, `string`), ` to\nbe printed (in this case to the terminal). If you wanted to output more than\none line from your program, you could update it to:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  print \"Hello World!\"\n  print \"Hello World!\"\n`)), mdx(\"p\", null, `When you run the updated program, you will see two lines of output:`), mdx(Tabs, {\n    mdxType: \"Tabs\"\n  }, mdx(Tab, {\n    label: \"Jaguar\",\n    mdxType: \"Tab\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-txt\"\n  }, `$ jag run -d host hello.toit\nHello World!\nHello World!\n`))), mdx(Tab, {\n    label: \"toitlang.org\",\n    mdxType: \"Tab\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-txt\"\n  }, `$ toit.run hello.toit\nHello World!\nHello World!\n`)))), mdx(\"h2\", {\n    \"id\": \"defining-a-function\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#defining-a-function\",\n    \"aria-label\": \"defining a function permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Defining a function`), mdx(\"p\", null, `What if you want to say \"Hello\" a lot without getting your fingers all tired? You should define another function:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `hi:\n  print \"Hello World!\"\n`)), mdx(\"p\", null, `and call that from `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `main`), `:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  hi\n  hi\n`)), mdx(\"p\", null, `Calling a function in Toit is as simple as mentioning its name. If the function\ndoesn't take arguments that's all you need.`), mdx(\"p\", null, `What if we want to say hello to one person, and not the whole world? Just redefine hi to take a name as an argument.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `hi name:\n  print \"Hello $name!\"\n`)), mdx(\"p\", null, `This way, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `hi`), ` is a function that takes a single argument. We can use that from `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `main`), `:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  hi \"Lars\"\n  hi \"Kasper\"\n`)), mdx(\"p\", null, `and it works!`), mdx(Tabs, {\n    mdxType: \"Tabs\"\n  }, mdx(Tab, {\n    label: \"Jaguar\",\n    mdxType: \"Tab\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-txt\"\n  }, `$ jag run -d host hello.toit\nHello Lars!\nHello Kasper!\n`))), mdx(Tab, {\n    label: \"toitlang.org\",\n    mdxType: \"Tab\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-txt\"\n  }, `$ toit.run hello.toit\nHello Lars!\nHello Kasper!\n`)))), mdx(\"h2\", {\n    \"id\": \"inserting-strings-in-strings\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#inserting-strings-in-strings\",\n    \"aria-label\": \"inserting strings in strings permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Inserting strings in strings`), mdx(\"p\", null, `What's the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `$name`), ` bit? That's Toit's way of inserting something into a string.\nIt is called `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./strings#string-interpolation\"\n  }, mdx(\"em\", {\n    parentName: \"a\"\n  }, `string interpolation`)), `.\nThe bit after the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `$`), ` is turned into a string (if it isn't one already) and\nthen substituted into the outer string at that point. You can also use this to\nmake sure that someone's name is properly trimmed so leading and trailing\nwhitespace is ignored:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `hi name=\"World\":\n  print \"Hello, $name.trim!\"\n`)), mdx(\"p\", null, `This way, we call the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `trim`), ` function on the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `name`), ` string before we insert it\ninto the outer string. If we call `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `hi \" Lars \"`), ` we still get the familiar\ngreeting `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Hello Lars!`), ` and not `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Hello Lars !`), `. You can add parentheses\naround the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `name.trim`), ` expression in the string to make it clearer which parts\nbelong to the outer string:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `  print \"Hello, $(name.trim)!\"\n`)), mdx(\"p\", null, `Maybe you already spotted that we went ahead and added one other trick to the\ncode above? We added a default value for the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `name`), ` parameter, so if the name\nisn't supplied when you call `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `hi`), `, we use the default name \"World\". Now we can\ntry:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  hi\n  hi \"Kasper\"\n`)), mdx(\"p\", null, `and get the following output:`), mdx(Tabs, {\n    mdxType: \"Tabs\"\n  }, mdx(Tab, {\n    label: \"Jaguar\",\n    mdxType: \"Tab\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-txt\"\n  }, `$ jag run -d host hello.toit\nHello World!\nHello Kasper!\n`))), mdx(Tab, {\n    label: \"toitlang.org\",\n    mdxType: \"Tab\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-txt\"\n  }, `$ toit.run hello.toit\nHello World!\nHello Kasper!\n`)))), mdx(\"h2\", {\n    \"id\": \"evolving-into-a-greeter\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#evolving-into-a-greeter\",\n    \"aria-label\": \"evolving into a greeter permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Evolving into a greeter`), mdx(\"p\", null, `What if we want a real greeter around, one that remembers your name and\nwelcomes you and treats you with respect. You might want to use an object for\nthat. Let's create a `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Greeter`), ` class:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class Greeter:\n  name := null\n\n  constructor .name=\"World\":\n\n  say-hi: print \"Hi $name.trim!\"\n\n  say-bye: print \"Bye $name.trim, come back soon.\"\n`)), mdx(\"p\", null, `The new keyword here is `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `class`), `. This defines a new class called `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Greeter`), ` and\na bunch of methods for that class. Methods are just functions that are attached\nto an object. Pay special attention to the method `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `constructor`), `. There is\nnothing after the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `:`), ` and the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `constructor`), ` method isn't followed by any\nindented lines, so the constructor has no statements in it:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `  constructor .name=\"World\":\n`)), mdx(\"p\", null, `This is a\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./objects-constructors-inheritance-interfaces#constructors\"\n  }, `constructor`), `\nand it defines how you can construct objects from the class. It says the class\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Greeter`), ` takes a single argument (`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `name`), `), but the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `.`), ` prefix to the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `.name`), `\nparameter actually tells us that the name is immediately stored as a field on\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Greeter`), ` objects. The field is defined just above the constructor with the\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `:=`), ` syntax.`), mdx(\"p\", null, `The field parameter `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `.name`), ` still has a default value, so if we don't pass a name, the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Greeter`), ` will greet the world.`), mdx(\"p\", null, `The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `say-hi`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `say-bye`), ` methods are introduced on the next two lines. The\nmethods both have a single statement in them, so we can keep them on one line\neach. The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `say-hi`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `say-bye`), ` method both use the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `name`), ` field from the\nobject they are called on. You can refer to fields in the class of a method\nsimply by mentioning them (`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `name`), `).`), mdx(\"h2\", {\n    \"id\": \"creating-a-greeter-object\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#creating-a-greeter-object\",\n    \"aria-label\": \"creating a greeter object permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Creating a greeter object`), mdx(\"p\", null, `Now let's create a greeter object and use it:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  greeter := Greeter \" Helena \"\n  greeter.say-hi\n  greeter.say-bye\n`)), mdx(\"p\", null, `We create an object simply by mentioning the constructor, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Greeter`), `. The\ngreeter object remembers the name and uses it for the two separate greetings.\nIf we run this, we get the following output:`), mdx(Tabs, {\n    mdxType: \"Tabs\"\n  }, mdx(Tab, {\n    label: \"Jaguar\",\n    mdxType: \"Tab\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-txt\"\n  }, `$ jag run -d host hello.toit\nHi Helena!\nBye Helena, come back soon.\n`))), mdx(Tab, {\n    label: \"toitlang.org\",\n    mdxType: \"Tab\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-txt\"\n  }, `$ toit.run hello.toit\nHi Helena!\nBye Helena, come back soon.\n`)))), mdx(\"p\", null, `If you want to get the name from a greeter, you can ask a greeter by calling the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `name`), ` method on it:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  greeter := Greeter \" Helena \"\n  print \"How are you $(greeter.name)?\"\n`)), mdx(\"p\", null, `This would show `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `How are you Helena ?`), `. Almost neat, right? Unfortunately, the\nname isn't trimmed like we expected. Let's fix that!`), mdx(\"h2\", {\n    \"id\": \"fields-and-methods\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#fields-and-methods\",\n    \"aria-label\": \"fields and methods permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Fields and methods`), mdx(\"p\", null, `As you have just seen, a field on an object introduces a method with the same\nname. If you wanted to hide a field from the outside world, you could make it\nprivate. By convention, methods and fields that end with an underscore (`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `_`), `)\nare private and not supposed to be touched from the outside:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class Greeter:\n  name_ := null\n  constructor .name_=\"World\":\n`)), mdx(\"p\", null, `This removes the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `name`), ` method from greeters, but if we really want to allow\naccessing the name from the outside, we could reintroduce a getter with the\nsame meaning as before.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class Greeter:\n  name_ := null\n\n  constructor .name_=\"World\":\n\n  name: return name_\n  say-hi: print \"Hi $name_.trim!\"\n  say-bye: print \"Bye $name_.trim, come back soon.\"\n`)), mdx(\"p\", null, `Here we use the new keyword `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `return`), ` to specify the value a method returns. We\ncould make it slightly more interesting and trim it in the process:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `  name: return name_.trim\n`)), mdx(\"p\", null, `In this way, access to the name from the outside also gets the trimming and we\ncan avoid having to manually call `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `trim`), ` when getting the name:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class Greeter:\n  name_ := null\n\n  constructor .name_=\"World\":\n\n  name: return name_.trim\n  say-hi: print \"Hi $name!\"\n  say-bye: print \"Bye $name, come back soon.\"\n`)), mdx(\"p\", null, `We can check that it works by running:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  greeter := Greeter \" Erik \"\n  print \"How are you $(greeter.name)?\"\n`)), mdx(\"p\", null, `and you should see `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `How are you Erik?`), `. `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `greeter`), ` is a local variable, only visible in the\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `main`), ` method. We declared it with the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `:=`), ` syntax, just like we used `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `:=`), ` to declare\nmember variables in classes.`), mdx(\"h2\", {\n    \"id\": \"greetings-everyone\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#greetings-everyone\",\n    \"aria-label\": \"greetings everyone permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Greetings everyone!`), mdx(\"p\", null, `This greeter isn't all that interesting though, it can only deal with one\nperson at a time. What if we had some kind of MegaGreeter that could either\ngreet the world, one person, or a whole list of people? Let's try to build\nthat. We will start with a class definition:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class MegaGreeter:\n  names := []\n\n  constructor name=\"World\":\n    names.add name\n`)), mdx(\"p\", null, `So MegaGreeter objects have a `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./listsetmap\"\n  }, `list`), ` of `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `names`), `. The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `names`), `\nfield is initialized to the empty list (`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `[]`), `). The body of the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `MegaGreeter`), `\nconstructor adds the given `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `name`), ` argument to the end of the list of names.\nNotice that this is different than using a `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `.name`), ` parameter that automatically\nassigns to the field called `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `name`), `. Mega greeters don't have a single name and\nno `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `name`), ` field, so here the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `name`), ` is just an ordinary parameter that we can\nuse in the body of the constructor. All in all, this code:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  greeter := MegaGreeter\n  print \"The names are $greeter.names\"\n`)), mdx(\"p\", null, `will lead to this output:`), mdx(Tabs, {\n    mdxType: \"Tabs\"\n  }, mdx(Tab, {\n    label: \"Jaguar\",\n    mdxType: \"Tab\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-txt\"\n  }, `$ jag run -d host hello.toit\nThe names are [World]\n`))), mdx(Tab, {\n    label: \"toitlang.org\",\n    mdxType: \"Tab\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-txt\"\n  }, `$ toit.run hello.toit\nThe names are [World]\n`)))), mdx(\"p\", null, `We can now go ahead and add greeter methods that show all the names:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `// Greeter that says hi to everybody.\nclass MegaGreeter:\n  names := []\n\n  constructor name=\"World\":\n    names.add name\n\n  say-hi:\n    // Greet everyone individually!\n    names.do: print \"Hello $it!\"\n  say-bye:\n    everyone := names.join \", \"\n    print \"Bye $everyone, come back soon.\"\n\nmain:\n  greeter := MegaGreeter\n  greeter.say-hi\n  greeter.say-bye\n\n  greeter.names.add \"Lars\"\n  greeter.names.add \"Kasper\"\n  greeter.names.add \"Rikke\"\n  greeter.say-hi\n  greeter.say-bye\n`)), mdx(\"p\", null, `If you run this, you'll get this output:`), mdx(Tabs, {\n    mdxType: \"Tabs\"\n  }, mdx(Tab, {\n    label: \"Jaguar\",\n    mdxType: \"Tab\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-txt\"\n  }, `$ jag run -d host hello.toit\nHello World!\nBye World, come back soon.\nHello World!\nHello Lars!\nHello Kasper!\nHello Rikke!\nBye World, Lars, Kasper, Rikke, come back soon.\n`))), mdx(Tab, {\n    label: \"toitlang.org\",\n    mdxType: \"Tab\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-txt\"\n  }, `$ toit.run hello.toit\nHello World!\nBye World, come back soon.\nHello World!\nHello Lars!\nHello Kasper!\nHello Rikke!\nBye World, Lars, Kasper, Rikke, come back soon.\n`)))), mdx(\"p\", null, `Let's dive into the new constructs in the next sections.`), mdx(\"h2\", {\n    \"id\": \"comments-and-indentation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#comments-and-indentation\",\n    \"aria-label\": \"comments and indentation permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Comments and indentation`), mdx(\"p\", null, `Not everything in your source files is meant to be run by the Toit compiler.\nSometimes, it is nice just to add comments that explain interesting things\nrelated to your code. In the example in the last section, there were a few\nsingle line comments:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `// Greeter that says hi to everybody.\nclass MegaGreeter:\n`)), mdx(\"p\", null, `Such comments start with `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `//`), ` and tell the system to ignore the rest of the line.`), mdx(\"p\", null, `You have already seen the use of indentation to give hierarchical structure to\nyour code. The general structure is that after a `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `:`), ` you can have a single\nconstruct if it fits on one line:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class SimpleGreeter:\n\n  say-hi: print \"Hi!\"  // Method all on one line.\n`)), mdx(\"p\", null, `or you can add a newline after the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `:`), ` and let the following lines that are\nindented relative to the outer construct be a sequence of inner constructs:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `  names := []\n\n  // Method delimited by indentation\n  say-bye:\n    everyone := names.join \", \"\n    print \"Bye $everyone, come back soon.\"\n`)), mdx(\"p\", null, `For methods, we often refer to the inner constructs as the statements of a\nmethod or the body of a method. The preferred indentation for inner constructs\nis two spaces.`), mdx(\"p\", null, `For a class, everything that is indented under the class declaration line\nbelongs to the class. We call such things class members:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class MegaGreeter:\n  // class members start\n  // ...\n  // class members end\n`)), mdx(\"p\", null, `For methods in a class, the statements in them are nested one level further (two spaces) than the class members:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class MegaGreeter:\n  // class members start\n  // ...\n  say-hi:\n    // method body start\n    // ...\n    // method body end\n  // ...\n  // class members end\n`)), mdx(\"p\", null, `It is common to refer to such nested structure as `, mdx(\"em\", {\n    parentName: \"p\"\n  }, `block structure`), `.`), mdx(\"h2\", {\n    \"id\": \"iterating-over-lists\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#iterating-over-lists\",\n    \"aria-label\": \"iterating over lists permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Iterating over lists`), mdx(\"p\", null, `Let's return to the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `MegaGreeter`), ` example and take a look at another place\nwhere constructs are block structured. In the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `say-hi`), ` method, we want to call\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `print`), ` for every single name in the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `names`), ` `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./listsetmap\"\n  }, `list`), `. We can do\nthis by calling `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `names.do`), ` and provide the list of statements we want to run\nfor each element using block structure:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `  say-hi:\n    // Greet everyone individually!\n    names.do: print \"Hello $it!\"\n`)), mdx(\"p\", null, `Here the statement is on a single line, so there is no need to use indentation.\nWhen using `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `names.do`), `, a method available on all\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./listsetmap\"\n  }, `collections`), `, the `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./blocks-and-lambdas#block-arguments\"\n  }, `special variable\n`, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, `it`)), ` contains the individual elements from the list in\nturn. If there are 5 elements in the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `names`), ` list, we will call `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `print`), ` 5 times\nproducing 5 separate lines of output.`), mdx(\"p\", null, `You can play with the methods on list by modifying and running the sample below:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  list := [ \"Horse\", \"Fish\", \"Radish\", \"Baboon\" ]\n  print \"There are $(list.size) elements in the list\"\n  print \"Here they are:\"\n  list.do: print \"Element = $it\"\n\n  print \"Here they are (sorted):\"\n  list.sort --in-place\n  list.do: print \"Element = $it\"\n`)), mdx(\"p\", null, `One of the methods on lists that is very useful when constructing strings is\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `join`), `. It produces a string from a list of strings by joining the parts and\nadding a separator between them. We use this in the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `MegaGreeter`), ` example to\nproduce a single comma-separated list of names for the single line output of\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `say-bye`), `:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `  say-bye:\n    everyone := names.join \", \"\n    print \"Bye $everyone, come back soon.\"\n`)), mdx(\"h2\", {\n    \"id\": \"named-arguments\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#named-arguments\",\n    \"aria-label\": \"named arguments permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Named arguments`), mdx(\"p\", null, `Perhaps you don't always want to say \"Hello\", so you add an argument with a default value to the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `say-hi`), ` method:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `  say-hi greeting=\"Hello,\":\n    // Greet everyone individually!\n    names.do: print \"$greeting $it!\"\n`)), mdx(\"p\", null, `Now the user of your class can write:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  greeter := MegaGreeter\n  greeter.names.add \"Lars\"\n  greeter.names.add \"Kasper\"\n  greeter.say-hi \"Kaixo,\"\n`)), mdx(\"p\", null, `Which produces the output:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-txt\"\n  }, `Kaixo, World!\nKaixo, Lars!\nKaixo, Kasper!\n`)), mdx(\"p\", null, `However, at the calling site it may not be clear what the argument \"Kaixo\" is\nfor. We can make it clearer with a named argument:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `  say-hi --greeting=\"Hello,\":\n    // Greet everyone individually!\n    names.do: print \"$greeting $it!\"\n`)), mdx(\"p\", null, `Now we can use this with:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  greeter := MegaGreeter\n  greeter.say-hi\n  greeter.names.add \"Lars\"\n  greeter.names.add \"Kasper\"\n  greeter.say-hi --greeting=\"Hej,\"\n`)), mdx(\"p\", null, `which outputs:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-txt\"\n  }, `Hello, World!\nHej, World!\nHej, Lars!\nHej, Kasper!\n`)), mdx(\"h2\", {\n    \"id\": \"if-statements-and-basic-expressions\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#if-statements-and-basic-expressions\",\n    \"aria-label\": \"if statements and basic expressions permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `If statements and basic expressions`), mdx(\"p\", null, `We can program a ridiculously inefficient Fibonacci sequence generator using `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `if`), ` and recursion:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `fib n:\n  if n <= 1: return n\n  return (fib n - 1) + (fib n - 2)\n\nmain:\n  print \"The 10th Fibonacci number is $(fib 10)\"\n`)), mdx(\"p\", null, `This defines a top-level function called `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `fib`), ` that is not a member of any\nclass. (We already saw `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `main`), `, which is a top level function with a special\nname.)`), mdx(\"p\", null, `The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `fib`), ` function is recursive, calling itself, and also makes use of a few\nnew features. The `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./loops#if-statements\"\n  }, `if-statement`), ` is well known from\nother languages. In Toit it works by taking an expression and conditionally\nevaluating a block. Like other blocks we could have used indentation to group\nmultiple lines.`), mdx(\"p\", null, `Toit also has the usual array of infix operators, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `+`), `, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `-`), `, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `*`), `, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `/`), `, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `%`), ` etc.\nand the relational operators `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `<`), `, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `<=`), `, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `>`), `, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `>=`), `, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `==`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `!=`), `. The\noperators have higher `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./syntax#precedence\"\n  }, `precedence`), ` than function\narguments, so we had to group the calls in parentheses to get the desired\nbehavior. The high precedence is what makes the arguments for the recursive\ninvocation of `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `fib`), ` work.`), mdx(\"h2\", {\n    \"id\": \"loops\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#loops\",\n    \"aria-label\": \"loops permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Loops`), mdx(\"p\", null, `This is a terribly slow way to calculate a Fibonacci number though, and we\ncould do it with a simple `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./loops#loops\"\n  }, `loop`), `:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `fib2 n:\n  s1 := 0\n  s2 := 1\n  n.repeat:\n    s3 := s1 + s2\n    s1 = s2\n    s2 = s3\n  return s1\n`)), mdx(\"p\", null, `Here we are using the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `repeat`), ` method on numbers, which runs a block a given\nnumber of times. Like for the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `do`), ` method, there's an automatic variable, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `it`), `\nthat gives the iteration number:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `// Prints the numbers from 0 to n (exclusive).\nprint-n-numbers n:\n  n.repeat: print it\n`)), mdx(\"p\", null, `The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `repeat`), ` method is simple and efficient, but sometimes we need something\nmore flexible, and for that we have the well-known `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `while`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `for`), `\nstatements:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `// Prints the odd numbers less than n.\nprint-odd-numbers n:\n  for i := 1; i < n; i += 2:\n    print i\n\n// Returns if the Collatz conjecture is true.\ncollatz n:\n  while n > 1:\n    if n % 2 == 0: n = n / 2\n    else: n = n * 3 + 1\n`)), mdx(\"h2\", {\n    \"id\": \"maps-and-sets\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#maps-and-sets\",\n    \"aria-label\": \"maps and sets permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Maps and sets`), mdx(\"p\", null, `Perhaps we need titles for our greeters:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class MegaGreeter:\n  names := []\n  titles := {:}\n\n  constructor:\n\n  add name title:\n    names.add name\n    titles[name] = title\n  say-hi:\n    // Greet everyone individually!\n    names.do: print \"Hello, $titles[it] $it!\"\n\nmain:\n  greeter := MegaGreeter\n  greeter.add \"Lars\" \"Mr.\"\n  greeter.add \"Rikke\" \"Dr.\"\n  greeter.add \"GÃ¼nter\" \"Herr Professor Doktor Doktor\"\n  greeter.say-hi\n`)), mdx(\"p\", null, `Here we use a `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./listsetmap\"\n  }, `hash map`), ` to store the appropriate title for each\nname. The empty map is given by `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `{:}`), ` and we use `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `[]`), ` to access the values for\neach key. The empty set is `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `{}`), ` and we already met the empty list, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `[]`), `. The\nlookup syntax `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `[]`), ` also works on lists, so instead of the 'do' method we could\nhave used:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `  say-hi:\n    for i := 0; i < names.size; i++:\n      print \"Hello, $names[i]\"\n`)), mdx(\"h2\", {\n    \"id\": \"blocks-and-lambdas\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#blocks-and-lambdas\",\n    \"aria-label\": \"blocks and lambdas permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Blocks and lambdas`), mdx(\"p\", null, `We already saw the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `repeat`), ` method on integers and the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `do`), ` method on lists:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  // Print the numbers from 1 to 10, one per line.\n  10.repeat:\n    print it + 1\n  my-list := [1, 2, 3]\n  // Print the elements in my-list, one per line.\n  my-list.do:\n    print it\n`)), mdx(\"p\", null, `Syntactically they look like they are built in to the language like `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `if`), ` and\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `for`), `, but they are actually normal methods on the List and int classes:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `class List:\n  // ...\n  do [block]:\n    size.repeat: block.call this[it]\n\nclass int:\n  // ...\n  repeat [block]:\n    for i := 0; i < this; i++:\n      block.call i\n`)), mdx(\"p\", null, `They are making use of a feature called `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./blocks-and-lambdas\"\n  }, `blocks`), `. These are\nsnippets of code that can be passed down the stack as arguments to methods and\nfunctions. At the call site we precede the block with a colon, '`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `:`), `', and at\nthe function definition we surround the parameter name with square brackets,\n'`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `[]`), `'. Often, there is one block parameter, it is in the final position and\nit is called `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `block`), `.`), mdx(\"p\", null, `If a callback needs to survive the scope in which it is defined, we can't use\nblocks. Instead, we can use `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./blocks-and-lambdas#lambdas\"\n  }, `lambdas`), `:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `// Returns a function that adds n to its argument.\nadd-n n -> Lambda:\n  return (:: it + n)\n`)), mdx(\"p\", null, `The syntax for lambdas is the same as for blocks, except that the we use `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `::`), `\ninstead of `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `:`), `. The lambda above is a function that takes a single argument and\nreturns the sum of that argument and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `n`), `. We can use it like this:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  add-5 := add-n 5\n  print (add-5.call 10)\n`)), mdx(\"p\", null, `This will print `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `15`), `.`), mdx(\"h2\", {\n    \"id\": \"blocks-and-lambdas-with-multiple-arguments\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#blocks-and-lambdas-with-multiple-arguments\",\n    \"aria-label\": \"blocks and lambdas with multiple arguments permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Blocks and lambdas with multiple arguments`), mdx(\"p\", null, `Blocks and lambdas can have parameters, just like methods. The parameters are\nlisted after the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `::`), ` or `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `:`), `. Here is an example of a block with two parameters:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  map := { \"Lars\": 1, \"Kasper\": 2 }\n  map.do: | key value |\n    print \"$key has value $value\"\n`)), mdx(\"p\", null, `The block in the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `do`), ` method has two parameters, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `key`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `value`), `. The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `do`), `\nmethod will call the block with each key-value pair in the map.`), mdx(\"h2\", {\n    \"id\": \"blocks-and-lambdas-that-return-a-value\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#blocks-and-lambdas-that-return-a-value\",\n    \"aria-label\": \"blocks and lambdas that return a value permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Blocks and lambdas that return a value`), mdx(\"p\", null, `A block or lambda can return a value each time it is run. This is used for example\nin the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `filter`), ` method on lists.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `// Takes a list of words, and returns a new list with only the\n// words that are 5 characters or fewer.\nshort-words words:\n  return words.filter:\n    it.size <= 5\n`)), mdx(\"p\", null, `The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `filter`), ` method calls the block, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `it.size <= 5`), ` for each element in the\noriginal list, and returns a new list containing only the short words.`), mdx(\"p\", null, `Note that there is no `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `return`), ` statement in the block. A block will return the\nvalue of the last statement to the place where it was invoked with\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `block.call`), `. In this case there is only one statement, which is the\n`, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./booleans\"\n  }, `boolean`), ` expression `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `it.size <= 5`), `.`), mdx(\"p\", null, `If you use the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `return`), ` keyword in a block then it returns from the syntactic\nfunction or method in which it is written. Usually this will behave as you\nwould expect:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `wheres-walter list:\n  list.do:\n    if it.starts-with \"Walter \":\n      return it\n  return null\n\nmain:\n  print (wheres-walter [\"Ib Michael\", \"Walter White\", \"Marie Curie\"])\n`)), mdx(\"p\", null, `The `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `return`), ` keyword is inside a block that is passed to the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `do`), ` method. When\nthe name that starts with `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `\"Walter \"`), ` is found we immediately return the full\nname from the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `wheres-walter`), ` function without continuing to iterate over the\nlist.`));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#language-basics","title":"Language basics","items":[{"url":"#hello-world","title":"Hello, World"},{"url":"#defining-a-function","title":"Defining a function"},{"url":"#inserting-strings-in-strings","title":"Inserting strings in strings"},{"url":"#evolving-into-a-greeter","title":"Evolving into a greeter"},{"url":"#creating-a-greeter-object","title":"Creating a greeter object"},{"url":"#fields-and-methods","title":"Fields and methods"},{"url":"#greetings-everyone","title":"Greetings everyone!"},{"url":"#comments-and-indentation","title":"Comments and indentation"},{"url":"#iterating-over-lists","title":"Iterating over lists"},{"url":"#named-arguments","title":"Named arguments"},{"url":"#if-statements-and-basic-expressions","title":"If statements and basic expressions"},{"url":"#loops","title":"Loops"},{"url":"#maps-and-sets","title":"Maps and sets"},{"url":"#blocks-and-lambdas","title":"Blocks and lambdas"},{"url":"#blocks-and-lambdas-with-multiple-arguments","title":"Blocks and lambdas with multiple arguments"},{"url":"#blocks-and-lambdas-that-return-a-value","title":"Blocks and lambdas that return a value"}]}]}}},"pageContext":{"title":"Language","id":"3030f1ac-fd8c-5447-b1ea-7b29000bee21"}},
    "staticQueryHashes": ["2197327828"]}