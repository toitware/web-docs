{
    "componentChunkName": "component---src-components-layout-mdx-layout-tsx",
    "path": "/language/tasks",
    "result": {"data":{"site":{"siteMetadata":{"title":"Toit documentation"}},"mdx":{"body":"const _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nconst _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return mdx(\"div\", props);\n};\n\nconst Note = makeShortcode(\"Note\");\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"tasks\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#tasks\",\n    \"aria-label\": \"tasks permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Tasks`), mdx(\"h2\", {\n    \"id\": \"introduction\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#introduction\",\n    \"aria-label\": \"introduction permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Introduction`), mdx(\"p\", null, `Some languages, like Java or C#, have multiple threads running at the same\ntime. These are separate control flows that can manipulate each other's data.\nBecause there can be different threads using the same objects, it is easy to\nmake programming mistakes called race conditions.`), mdx(\"p\", null, `Other languages, like JavaScript, have only one thread. This is very limiting\nin that your program constantly has to return to an `, mdx(\"em\", {\n    parentName: \"p\"\n  }, `event loop`), `, which makes\nit much harder to program. Your code must be written in a `, mdx(\"em\", {\n    parentName: \"p\"\n  }, `non-blocking`), ` style\nwith no long-running loops.`), mdx(\"h2\", {\n    \"id\": \"tasks-1\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#tasks-1\",\n    \"aria-label\": \"tasks 1 permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Tasks`), mdx(\"p\", null, `Toit has a third option instead: Tasks (sometimes called fibers in other\nlanguages). Tasks have independent control flow but do not run simultaneously.\nAn example:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `import gpio\n\n// The red LED is connected to pin 17.\nLED1 ::= gpio.Pin.out 17\n// The green LED is connected to pin 18.\nLED2 ::= gpio.Pin.out 18\n\nmain:\n  // Note the double \\`::\\` on the next two lines.\n  // Start a task that runs the my-task-1 function.\n  task:: my-task-1\n  // Start a second task that runs my-task-2.\n  task:: my-task-2\n\nmy-task-1:\n  while true:\n    sleep --ms=500\n    LED1.set 1\n    sleep --ms=500\n    LED1.set 0\n\nmy-task-2:\n  while true:\n    sleep --ms=123\n    LED2.set 1\n    sleep --ms=123\n    LED2.set 0\n`)), mdx(\"p\", null, `In this program, there are two tasks started with `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `task::`), `. Each of them has an\ninfinite loop (`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `while true`), `), but because they have independent control flow,\nthey can both take turns to run. They run in the same heap, so they see the\nsame objects (in theory task 1 could access the same LED as task 2, though it\nmight be confusing).`), mdx(\"p\", null, `In this example, we can see that tasks or threads simplify the programming\nconsiderably. One LED is flashing once per second, while the other is flashing\nevery 246ms. To code this in one loop, we would have to write a program that\nswitched the LEDs at the times 0, 123, 246, 369, 492, 500, 615ms etc.\nAlternatively to code this in an event-driven language like JavaScript, we\nwould have to remove all the loops and instead use a state machine with\nscheduled callbacks to perform the LED switching and update variables that\nrepresent state (in this case to track whether the next callback should switch\non or off).`), mdx(\"h2\", {\n    \"id\": \"cooperative-scheduling\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#cooperative-scheduling\",\n    \"aria-label\": \"cooperative scheduling permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Cooperative scheduling`), mdx(\"p\", null, `Unlike threads, the tasks in Toit do not actually run at the same time as each\nother. The program only switches to a different task when the previous task\nstops to wait for something. One way to wait is with the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `sleep`), ` function, but\nthere are other ways, for example waiting for a GPIO pin to change with\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `pin.wait-for`), `. This is both a limitation and a simplification for the\nprogrammer. On the negative side, a task can block all other tasks, by never\nwaiting (also called `, mdx(\"em\", {\n    parentName: \"p\"\n  }, `yielding`), `). For example:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `main:\n  task:: my-uncooperative-task\n  task:: my-starved-task\n\nmy-uncooperative-task:\n  M ::= 1_000_000\n  M.repeat:\n    x := it + 1\n    M.repeat:\n      y := it + 1\n      M.repeat:\n        z := it + 1\n        if x*x*x + y*y*y == z*z*z:\n          print \"\"\"\n            Fermat's last theorem disproved!  \\\\\n            $x^3 + $y^3 = $z^3\"\"\"\n          return\n\nmy-starved-task:\n  while true:\n    sleep --ms=100\n    print \"If you see this, the task is running.\"\n`)), mdx(\"p\", null, `In this example, the first task is attempting to find a counterexample to\nFermat's Last Theorem. This will take a long time, since no such counterexample\nexists. While it is calculating, it doesn't wait for anything (yield), and so\nno other tasks can run. As soon as the uncooperative task starts running it hogs\nthe CPU and prevents other tasks from running, stopping 'my-starved-task' from\nemitting messages (if it ever did so).\ntask will stop appearing.`), mdx(\"p\", null, `The advantage of tasks in comparison with threads is that they take turns. To\ntake an oversimplified example:`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `import gpio\nimport gpio.adc as gpio\n\n// The analog input is connected to pin 17.\nADC1 ::= gpio.Adc (gpio.Pin.in 17)\n\nclass VoltageStatus:\n  mv /int := 0\n  missing-mv /int := 0\n  goal /int := ?\n\n  constructor .goal:\n\n  update new-mv/int -> none:\n    mv = new-mv\n    missing-mv = goal - mv\n\nstatus := VoltageStatus 554  // Aim for 554millivolts.\n\nmain:\n  task:: my-task-1\n  task:: my-task-2\n\n/**\nUpdates the status object with the measured voltage\n  every 100ms.\n*/\nmy-task-1:\n  while true:\n    sleep --ms=100\n    value := ADC1.get\n    status.update (value * 1000).to-int\n\n/// Prints the current status every 123ms.\nmy-task-2:\n  while true:\n    sleep --ms=123\n    print \"Voltage is $(status.mv)mV\"\n    print \"We are $(status.missing-mv)mV from our target\"\n\n`)), mdx(\"p\", null, `This code looks rather simple and would work OK in Toit, but if we had threads\ninstead of tasks it would contain a race condition. The two fields of the\nstatus object, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `mv`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `missing-mv`), ` are not updated at the exact same moment.\nThe printing thread might read values of `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `mv`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `missing-mv`), ` that do not fit\ntogether because the other thread has updated one, but not the other.`), mdx(\"p\", null, `In Toit we only switch tasks at yield points. In this case the yield points are\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `sleep`), ` and `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `print`), `. There is no yield point in the middle of the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `update`), `\nmethod, and there is also no yield point while building up the string to be\nprinted, so the tasks do not see inconsistent versions of the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `status`), ` object.`), mdx(\"p\", null, `This rather contrived example also illustrates that the two tasks are running\non the same heap, and see the same instance of the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `status`), ` object. The two\ntasks are part of the same program even though they have independent call\nstacks and loops.`), mdx(\"h2\", {\n    \"id\": \"synchronizing-between-tasks-with-monitors\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#synchronizing-between-tasks-with-monitors\",\n    \"aria-label\": \"synchronizing between tasks with monitors permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Synchronizing between tasks with Monitors`), mdx(\"p\", null, `Sometimes you need to control when two tasks run, relative to each other. For\nthis there are some useful classes in the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `import monitor`), ` library.`), mdx(\"h3\", {\n    \"id\": \"latch\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#latch\",\n    \"aria-label\": \"latch permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Latch`), mdx(\"p\", null, `One of the simplest of the classes in `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `import monitor`), ` is `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Latch`), ` that allows\none task to wait until a value (object) has been provided by another task.`), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, `import monitor\n\n// Create a Latch object.\nlatch := monitor.Latch\n\nmain:\n  task:: producer-task-code\n  task:: consumer-task-code\n\nproducer-task-code:\n  // Call some do-other-processing function to compute some value.\n  result := do-other-processing\n\n  // This unblocks the other task, if it is already waiting\n  // on latch.get.\n  latch.set result\n\nconsumer-task-code:\n  // Call some do-processing function to compute some value.\n  my-result := do-processing\n  // Blocks until the other task is done collecting a\n  // result.\n  other-result := latch.get\n  print \"Result was $(my-result + other-result)\"\n\ndo-other-processing:\n  // Compute some value...\n  return 0\n\ndo-processing:\n  // Compute some value...\n  return 0\n`)), mdx(Note, {\n    type: \"warning\",\n    mdxType: \"Note\"\n  }, mdx(\"p\", null, `In this example we use the Latch class, but we don't inherit from it.\nIn general, inheriting from classes from `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `import monitor`), ` will cause unexpected\ndeadlocks in your program and is not recommended.`)), mdx(\"h3\", {\n    \"id\": \"channel\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#channel\",\n    \"aria-label\": \"channel permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Channel`), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Channel`), ` is like `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `Latch`), `, but supports multiple messages, sent from the\nproducer to the consumer. The channel has a capacity, which controls how many\nmessages (objects) can be buffered. If the producer tries send more than\n`, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `capacity`), ` unread messages in the channel, the producer blocks until the\nconsumer task receives a message, freeing up capacity.`), mdx(\"h3\", {\n    \"id\": \"semaphore\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#semaphore\",\n    \"aria-label\": \"semaphore permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Semaphore`), mdx(\"p\", null, `The Semaphore is a `, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Semaphore_(programming)\"\n  }, `well\nknown`), ` synchronization\nobject. The counter is incremented\nwith the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `up`), ` method, which cannot block (originally called V). The counter is\ndecremented with the `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `down`), ` method (originally called P) which blocks until it\nhas a non-zero internal counter to decrement.`), mdx(\"h3\", {\n    \"id\": \"mutex\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#mutex\",\n    \"aria-label\": \"mutex permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Mutex`), mdx(\"p\", null, `The Mutex has a single method, `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `do`), ` which takes a block of code to execute.\nOnly one task can run code at a time. The mutex is not reentrant.`), mdx(\"h3\", {\n    \"id\": \"mailbox\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#mailbox\",\n    \"aria-label\": \"mailbox permalink\",\n    \"className\": \"table-of-contents-icon before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), `Mailbox`), mdx(\"p\", null, `The Mailbox can send multiple messages between tasks. Like the latch (and\nunlike the Channel) it doesn't have the ability to buffer messages. The\nreceiver (consumer) must acknowledge each message with a response, sent with\nthe `, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, `reply`), ` method.`));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#tasks","title":"Tasks","items":[{"url":"#introduction","title":"Introduction"},{"url":"#tasks-1","title":"Tasks"},{"url":"#cooperative-scheduling","title":"Cooperative scheduling"},{"url":"#synchronizing-between-tasks-with-monitors","title":"Synchronizing between tasks with Monitors","items":[{"url":"#latch","title":"Latch"},{"url":"#channel","title":"Channel"},{"url":"#semaphore","title":"Semaphore"},{"url":"#mutex","title":"Mutex"},{"url":"#mailbox","title":"Mailbox"}]}]}]}}},"pageContext":{"title":"Tasks","id":"35742a8f-3241-5e2c-9656-c5bebeba91c4"}},
    "staticQueryHashes": ["2197327828"]}